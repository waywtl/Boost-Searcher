<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Users' Guide</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../proto.html" title="Chapter 31. Boost.Proto">
<link rel="prev" href="../proto.html" title="Chapter 31. Boost.Proto">
<link rel="next" href="reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../proto.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../proto.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="proto.users_guide"></a><a class="link" href="users_guide.html" title="Users' Guide">Users' Guide</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started">Getting Started</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end">Fronts Ends: Defining
      Terminals and Non-Terminals of Your EDSL</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form">Intermediate
      Form: Understanding and Introspecting Expressions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.back_end">Back Ends: Making Expression
      Templates Do Useful Work</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.examples">Examples</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.resources">Background and Resources</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.glossary">Glossary</a></span></dt>
</dl></div>
<h4>
<a name="proto.users_guide.h0"></a>
      <span class="phrase"><a name="proto.users_guide.compilers__compiler_construction_toolkits__and_proto"></a></span><a class="link" href="users_guide.html#proto.users_guide.compilers__compiler_construction_toolkits__and_proto">Compilers,
      Compiler Construction Toolkits, and Proto</a>
    </h4>
<p>
      Most compilers have front ends and back ends. The front end parses the text
      of an input program into some intermediate form like an abstract syntax tree,
      and the back end takes the intermediate form and generates an executable from
      it.
    </p>
<p>
      A library built with Proto is essentially a compiler for an embedded domain-specific
      language (EDSL). It also has a front end, an intermediate form, and a back
      end. The front end is comprised of the symbols (a.k.a., terminals), members,
      operators and functions that make up the user-visible aspects of the EDSL.
      The back end is made of evaluation contexts and transforms that give meaning
      and behavior to the expression templates generated by the front end. In between
      is the intermediate form: the expression template itself, which is an abstract
      syntax tree in a very real sense.
    </p>
<p>
      To build a library with Proto, you will first decide what your interface will
      be; that is, you'll design a programming language for your domain and build
      the front end with tools provided by Proto. Then you'll design the back end
      by writing evaluation contexts and/or transforms that accept expression templates
      and do interesting things with them.
    </p>
<p>
      This users' guide is organized as follows. After a <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started" title="Getting Started">Getting
      Started guide</a>, we'll cover the tools Proto provides for defining and
      manipulating the three major parts of a compiler:
    </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.front_end" title="Fronts Ends: Defining Terminals and Non-Terminals of Your EDSL">Front Ends</a></span></dt>
<dd><p>
            How to define the aspects of your EDSL with which your users will interact
            directly.
          </p></dd>
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form" title="Intermediate Form: Understanding and Introspecting Expressions">Intermediate
        Form</a></span></dt>
<dd><p>
            What Proto expression templates look like, how to discover their structure
            and access their constituents.
          </p></dd>
<dt><span class="term"><a class="link" href="users_guide.html#boost_proto.users_guide.back_end" title="Back Ends: Making Expression Templates Do Useful Work">Back Ends</a></span></dt>
<dd><p>
            How to define evaluation contexts and transforms that make expression
            templates do interesting things.
          </p></dd>
</dl>
</div>
<p>
      After that, you may be interested in seeing some <a class="link" href="users_guide.html#boost_proto.users_guide.examples" title="Examples">Examples</a>
      to get a better idea of how the pieces all fit together.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.getting_started"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started" title="Getting Started">Getting Started</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto">Installing
        Proto</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.naming">Naming
        Conventions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.hello_world">Hello
        World</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator">Hello
        Calculator</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.installing_proto"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto" title="Installing Proto">Installing
        Proto</a>
</h4></div></div></div>
<h6>
<a name="boost_proto.users_guide.getting_started.installing_proto.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.installing_proto.getting_proto"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.getting_proto">Getting
          Proto</a>
        </h6>
<p>
          You can get Proto by downloading Boost (Proto is in version 1.37 and later),
          or by accessing Boost's SVN repository on SourceForge.net. Just go to
          <a href="http://svn.boost.org/trac/boost/wiki/BoostSubversion" target="_top">http://svn.boost.org/trac/boost/wiki/BoostSubversion</a>
          and follow the instructions there for anonymous SVN access.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.installing_proto.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.installing_proto.building_with_proto"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.building_with_proto">Building
          with Proto</a>
        </h6>
<p>
          Proto is a header-only template library, which means you don't need to
          alter your build scripts or link to any separate lib file to use it. All
          you need to do is <code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>. Or, you might decide to just include
          the core of Proto (<code class="computeroutput"><span class="preprocessor">#include</span>
          <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">core</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>) and whichever contexts and transforms
          you happen to use.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.installing_proto.h2"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.installing_proto.requirements"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.requirements">Requirements</a>
        </h6>
<p>
          Proto depends on Boost. You must use either Boost version 1.34.1 or higher,
          or the version in SVN trunk.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.installing_proto.h3"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.installing_proto.supported_compilers"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.installing_proto.supported_compilers">Supported
          Compilers</a>
        </h6>
<p>
          Currently, Boost.Proto is known to work on the following compilers:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Visual C++ 8 and higher
            </li>
<li class="listitem">
              GNU C++ 3.4 and higher
            </li>
<li class="listitem">
              Intel on Linux 8.1 and higher
            </li>
<li class="listitem">
              Intel on Windows 9.1 and higher
            </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            Please send any questions, comments and bug reports to eric &lt;at&gt;
            boostpro &lt;dot&gt; com.
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.naming"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming" title="Naming Conventions">Naming
        Conventions</a>
</h4></div></div></div>
<p>
          Proto is a large library and probably quite unlike any library you've used
          before. Proto uses some consistent naming conventions to make it easier
          to navigate, and they're described below.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.naming.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.naming.functions"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.functions">Functions</a>
        </h6>
<p>
          All of Proto's functions are defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace. For example, there is a function called <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> defined in <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          that accepts a terminal expression and returns the terminal's value.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.naming.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.naming.metafunctions"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.metafunctions">Metafunctions</a>
        </h6>
<p>
          Proto defines <span class="emphasis"><em>metafunctions</em></span> that correspond to each
          of Proto's free functions. The metafunctions are used to compute the functions'
          return types. All of Proto's metafunctions live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span></code>
          namespace and have the same name as the functions to which they correspond.
          For instance, there is a class template <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code> that you can use to compute the
          return type of the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> function.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.naming.h2"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.naming.function_objects"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.function_objects">Function
          Objects</a>
        </h6>
<p>
          Proto defines <span class="emphasis"><em>function object</em></span> equivalents of all of
          its free functions. (A function object is an instance of a class type that
          defines an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          member function.) All of Proto's function object types are defined in the
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span></code> namespace and have the same
          name as their corresponding free functions. For example, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span></code> is a class that defines a function
          object that does the same thing as the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code> free function.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.naming.h3"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.naming.primitive_transforms"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.naming.primitive_transforms">Primitive
          Transforms</a>
        </h6>
<p>
          Proto also defines <span class="emphasis"><em>primitive transforms</em></span> -- class types
          that can be used to compose larger transforms for manipulating expression
          trees. Many of Proto's free functions have corresponding primitive transforms.
          These live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace and their names have a leading underscore. For instance, the
          transform corresponding to the <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> function is called <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>.
        </p>
<p>
          The following table summarizes the discussion above:
        </p>
<div class="table">
<a name="boost_proto.users_guide.getting_started.naming.t0"></a><p class="title"><b>Table 31.1. Proto Naming Conventions</b></p>
<div class="table-contents"><table class="table" summary="Proto Naming Conventions">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Entity
                  </p>
                </th>
<th>
                  <p>
                    Example
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    Free Function
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">()</span></code>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Metafunction
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value</span><span class="special">&lt;&gt;</span></code>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Function Object
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">functional</span><span class="special">::</span><span class="identifier">value</span></code>
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Transform
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_value</span></code>
                  </p>
                </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.hello_world"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_world" title="Hello World">Hello
        World</a>
</h4></div></div></div>
<p>
          Below is a very simple program that uses Proto to build an expression template
          and then execute it.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">typeof</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">ostream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">evaluate</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span> <span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          This program outputs the following:
        </p>
<pre class="programlisting">hello, world
</pre>
<p>
          This program builds an object representing the output operation and passes
          it to an <code class="computeroutput"><span class="identifier">evaluate</span><span class="special">()</span></code>
          function, which then executes it.
        </p>
<p>
          The basic idea of expression templates is to overload all the operators
          so that, rather than evaluating the expression immediately, they build
          a tree-like representation of the expression so that it can be evaluated
          later. For each operator in an expression, at least one operand must be
          Protofied in order for Proto's operator overloads to be found. In the expression
          ...
        </p>
<pre class="programlisting"><span class="identifier">cout_</span> <span class="special">&lt;&lt;</span> <span class="string">"hello"</span> <span class="special">&lt;&lt;</span> <span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="string">" world"</span>
</pre>
<p>
          ... the Protofied sub-expression is <code class="computeroutput"><span class="identifier">cout_</span></code>,
          which is the Proto-ification of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code>.
          The presence of <code class="computeroutput"><span class="identifier">cout_</span></code> "infects"
          the expression, and brings Proto's tree-building operator overloads into
          consideration. Any literals in the expression are then Protofied by wrapping
          them in a Proto terminal before they are combined into larger Proto expressions.
        </p>
<p>
          Once Proto's operator overloads have built the expression tree, the expression
          can be lazily evaluated later by walking the tree. That is what <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">()</span></code>
          does. It is a general tree-walking expression evaluator, whose behavior
          is customizable via a <span class="emphasis"><em>context</em></span> parameter. The use of
          <code class="computeroutput"><a class="link" href="../boost/proto/context/default_context.html" title="Struct default_context">proto::default_context</a></code>
          assigns the standard meanings to the operators in the expression. (By using
          a different context, you could give the operators in your expressions different
          semantics. By default, Proto makes no assumptions about what operators
          actually <span class="emphasis"><em>mean</em></span>.)
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_world.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_world.proto_design_philosophy"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_world.proto_design_philosophy">Proto
          Design Philosophy</a>
        </h6>
<p>
          Before we continue, let's use the above example to illustrate an important
          design principle of Proto's. The expression template created in the <span class="emphasis"><em>hello
          world</em></span> example is totally general and abstract. It is not tied
          in any way to any particular domain or application, nor does it have any
          particular meaning or behavior on its own, until it is evaluated in a
          <span class="emphasis"><em>context</em></span>. Expression templates are really just heterogeneous
          trees, which might mean something in one domain, and something else entirely
          in a different one.
        </p>
<p>
          As we'll see later, there is a way to create Proto expression trees that
          are <span class="emphasis"><em>not</em></span> purely abstract, and that have meaning and
          behaviors independent of any context. There is also a way to control which
          operators are overloaded for your particular domain. But that is not the
          default behavior. We'll see later why the default is often a good thing.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.getting_started.hello_calculator"></a><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
        Calculator</a>
</h4></div></div></div>
<p>
          "Hello, world" is nice, but it doesn't get you very far. Let's
          use Proto to build a EDSL (embedded domain-specific language) for a lazily-evaluated
          calculator. We'll see how to define the terminals in your mini-language,
          how to compose them into larger expressions, and how to define an evaluation
          context so that your expressions can do useful work. When we're done, we'll
          have a mini-language that will allow us to declare a lazily-evaluated arithmetic
          expression, such as <code class="computeroutput"><span class="special">(</span><span class="identifier">_2</span>
          <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span>
          <span class="special">*</span> <span class="number">100</span></code>,
          where <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code> are placeholders for values to be
          passed in when the expression is evaluated.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.defining_terminals"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.defining_terminals">Defining
          Terminals</a>
        </h6>
<p>
          The first order of business is to define the placeholders <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="identifier">_2</span></code>.
          For that, we'll use the <code class="computeroutput"><a class="link" href="../boost/proto/terminal.html" title="Struct template terminal">proto::terminal&lt;&gt;</a></code>
          metafunction.
        </p>
<pre class="programlisting"><span class="comment">// Define a placeholder type</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="comment">// Define the Protofied placeholder terminals</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p>
          The initialization may look a little odd at first, but there is a good
          reason for doing things this way. The objects <code class="computeroutput"><span class="identifier">_1</span></code>
          and <code class="computeroutput"><span class="identifier">_2</span></code> above do not require
          run-time construction -- they are <span class="emphasis"><em>statically initialized</em></span>,
          which means they are essentially initialized at compile time. See the
          <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">Static
          Initialization</a> section in the <a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix C: Rationale">Rationale</a>
          appendix for more information.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.constructing_expression_trees">Constructing
          Expression Trees</a>
        </h6>
<p>
          Now that we have terminals, we can use Proto's operator overloads to combine
          these terminals into larger expressions. So, for instance, we can immediately
          say things like:
        </p>
<pre class="programlisting"><span class="comment">// This builds an expression template</span>
<span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">;</span>
</pre>
<p>
          This creates an expression tree with a node for each operator. The type
          of the resulting object is large and complex, but we are not terribly interested
          in it right now.
        </p>
<p>
          So far, the object is just a tree representing the expression. It has no
          behavior. In particular, it is not yet a calculator. Below we'll see how
          to make it a calculator by defining an evaluation context.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h2"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.evaluating_expression_trees">Evaluating
          Expression Trees</a>
        </h6>
<p>
          No doubt you want your expression templates to actually <span class="emphasis"><em>do</em></span>
          something. One approach is to define an <span class="emphasis"><em>evaluation context</em></span>.
          The context is like a function object that associates behaviors with the
          node types in your expression tree. The following example should make it
          clear. It is explained below.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">calculator_context</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">callable_context</span><span class="special">&lt;</span> <span class="identifier">calculator_context</span> <span class="keyword">const</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// Values to replace the placeholders</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">args</span><span class="special">;</span>

    <span class="comment">// Define the result type of the calculator.</span>
    <span class="comment">// (This makes the calculator_context "callable".)</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Handle the placeholders:</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">args</span><span class="special">[</span><span class="identifier">I</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          In <code class="computeroutput"><span class="identifier">calculator_context</span></code>,
          we specify how Proto should evaluate the placeholder terminals by defining
          the appropriate overloads of the function call operator. For any other
          nodes in the expression tree (e.g., arithmetic operations or non-placeholder
          terminals), Proto will evaluate the expression in the "default"
          way. For example, a binary plus node is evaluated by first evaluating the
          left and right operands and adding the results. Proto's default evaluator
          uses the <a href="../../../libs/typeof/index.html" target="_top">Boost.Typeof</a>
          library to compute return types.
        </p>
<p>
          Now that we have an evaluation context for our calculator, we can use it
          to evaluate our arithmetic expressions, as below:
        </p>
<pre class="programlisting"><span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">45</span><span class="special">);</span> <span class="comment">// the value of _1 is 45</span>
<span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">50</span><span class="special">);</span> <span class="comment">// the value of _2 is 50</span>

<span class="comment">// Create an arithmetic expression and immediately evaluate it</span>
<span class="keyword">double</span> <span class="identifier">d</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span>

<span class="comment">// This prints "10"</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">d</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
          Later, we'll see how to define more interesting evaluation contexts and
          expression transforms that give you total control over how your expressions
          are evaluated.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h3"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.customizing_expression_trees">Customizing
          Expression Trees</a>
        </h6>
<p>
          Our calculator EDSL is already pretty useful, and for many EDSL scenarios,
          no more would be needed. But let's keep going. Imagine how much nicer it
          would be if all calculator expressions overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> so that they could be used as function
          objects. We can do that by creating a calculator <span class="emphasis"><em>domain</em></span>
          and telling Proto that all expressions in the calculator domain have extra
          members. Here is how to define a calculator domain:
        </p>
<pre class="programlisting"><span class="comment">// Forward-declare an expression wrapper</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span><span class="special">;</span>

<span class="comment">// Define a calculator domain. Expression within</span>
<span class="comment">// the calculator domain will be wrapped in the</span>
<span class="comment">// calculator&lt;&gt; expression wrapper.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          type will be an expression wrapper. It will behave just like the expression
          that it wraps, but it will have extra member functions that we will define.
          The <code class="computeroutput"><span class="identifier">calculator_domain</span></code> is
          what informs Proto about our wrapper. It is used below in the definition
          of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>.
          Read on for a description.
        </p>
<pre class="programlisting"><span class="comment">// Define a calculator expression wrapper. It behaves just like</span>
<span class="comment">// the expression it wraps, but with an extra operator() member</span>
<span class="comment">// function that evaluates the expression.    </span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">())</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Overload operator() to invoke proto::eval() with</span>
    <span class="comment">// our calculator_context.</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a1</span><span class="special">);</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">a2</span><span class="special">);</span>

        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
          struct is an expression <span class="emphasis"><em>extension</em></span>. It uses <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;&gt;</span></code>
          to effectively add additional members to an expression type. When composing
          larger expressions from smaller ones, Proto notes what domain the smaller
          expressions are in. The larger expression is in the same domain and is
          automatically wrapped in the domain's extension wrapper.
        </p>
<p>
          All that remains to be done is to put our placeholders in the calculator
          domain. We do that by wrapping them in our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper, as below:
        </p>
<pre class="programlisting"><span class="comment">// Define the Protofied placeholder terminals, in the</span>
<span class="comment">// calculator domain.</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<p>
          Any larger expression that contain these placeholders will automatically
          be wrapped in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper and have our <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
          overload. That means we can use them as function objects as follows.
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">result</span> <span class="special">=</span> <span class="special">((</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">)(</span><span class="number">45.0</span><span class="special">,</span> <span class="number">50.0</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">(</span><span class="number">50.0</span> <span class="special">-</span> <span class="number">45.0</span><span class="special">)</span> <span class="special">/</span> <span class="number">50.0</span> <span class="special">*</span> <span class="number">100</span><span class="special">));</span>
</pre>
<p>
          Since calculator expressions are now valid function objects, we can use
          them with standard algorithms, as shown below:
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">a1</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">56</span><span class="special">,</span> <span class="number">84</span><span class="special">,</span> <span class="number">37</span><span class="special">,</span> <span class="number">69</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a2</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">65</span><span class="special">,</span> <span class="number">120</span><span class="special">,</span> <span class="number">60</span><span class="special">,</span> <span class="number">70</span> <span class="special">};</span>
<span class="keyword">double</span> <span class="identifier">a3</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">0</span> <span class="special">};</span>

<span class="comment">// Use std::transform() and a calculator expression</span>
<span class="comment">// to calculate percentages given two input sequences:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">a1</span><span class="special">,</span> <span class="identifier">a1</span><span class="special">+</span><span class="number">4</span><span class="special">,</span> <span class="identifier">a2</span><span class="special">,</span> <span class="identifier">a3</span><span class="special">,</span> <span class="special">(</span><span class="identifier">_2</span> <span class="special">-</span> <span class="identifier">_1</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">_2</span> <span class="special">*</span> <span class="number">100</span><span class="special">);</span>
</pre>
<p>
          Now, let's use the calculator example to explore some other useful features
          of Proto.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h4"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.detecting_invalid_expressions">Detecting
          Invalid Expressions</a>
        </h6>
<p>
          You may have noticed that you didn't have to define an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">-()</span></code>
          or <code class="computeroutput"><span class="keyword">operator</span><span class="special">/()</span></code>
          -- Proto defined them for you. In fact, Proto overloads <span class="emphasis"><em>all</em></span>
          the operators for you, even though they may not mean anything in your domain-specific
          language. That means it may be possible to create expressions that are
          invalid in your domain. You can detect invalid expressions with Proto by
          defining the <span class="emphasis"><em>grammar</em></span> of your domain-specific language.
        </p>
<p>
          For simplicity, assume that our calculator EDSL should only allow addition,
          subtraction, multiplication and division. Any expression involving any
          other operator is invalid. Using Proto, we can state this requirement by
          defining the grammar of the calculator EDSL. It looks as follows:
        </p>
<pre class="programlisting"><span class="comment">// Define the grammar of calculator expressions</span>
<span class="keyword">struct</span> <span class="identifier">calculator_grammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          You can read the above grammar as follows: an expression tree conforms
          to the calculator grammar if it is a binary plus, minus, multiplies or
          divides node, where both child nodes also conform to the calculator grammar;
          or if it is a terminal. In a Proto grammar, <code class="computeroutput"><a class="link" href="../boost/proto/_.html" title="Struct _">proto::_</a></code> is a wildcard that matches
          any type, so <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span>
          <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span></code>
          matches any terminal, whether it is a placeholder or a literal.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This grammar is actually a little looser than we would like. Only placeholders
            and literals that are convertible to doubles are valid terminals. Later
            on we'll see how to express things like that in Proto grammars.
          </p></td></tr>
</table></div>
<p>
          Once you have defined the grammar of your EDSL, you can use the <code class="computeroutput"><a class="link" href="../boost/proto/matches.html" title="Struct template matches">proto::matches&lt;&gt;</a></code> metafunction to check
          whether a given expression type conforms to the grammar. For instance,
          we might add the following to our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> overload:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="comment">/* ... as before ... */</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">/* ... */</span>
    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">a1</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">a2</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// Check here that the expression we are about to</span>
        <span class="comment">// evaluate actually conforms to the calculator grammar.</span>
        <span class="identifier">BOOST_MPL_ASSERT</span><span class="special">((</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator_grammar</span><span class="special">&gt;));</span>
        <span class="comment">/* ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          The addition of the <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> line enforces at compile time that we
          only evaluate expressions that conform to the calculator EDSL's grammar.
          With Proto grammars, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code> it is very easy to give the users of
          your EDSL short and readable compile-time errors when they accidentally
          misuse your EDSL.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code class="computeroutput"><span class="identifier">BOOST_MPL_ASSERT</span><span class="special">()</span></code>
            is part of the Boost Metaprogramming Library. To use it, just <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">assert</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
          </p></td></tr>
</table></div>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h5"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.controlling_operator_overloads">Controlling
          Operator Overloads</a>
        </h6>
<p>
          Grammars and <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">matches</span><span class="special">&lt;&gt;</span></code>
          make it possible to detect when a user has created an invalid expression
          and issue a compile-time error. But what if you want to prevent users from
          creating invalid expressions in the first place? By using grammars and
          domains together, you can disable any of Proto's operator overloads that
          would create an invalid expression. It is as simple as specifying the EDSL's
          grammar when you define the domain, as shown below:
        </p>
<pre class="programlisting"><span class="comment">// Define a calculator domain. Expression within</span>
<span class="comment">// the calculator domain will be wrapped in the</span>
<span class="comment">// calculator&lt;&gt; expression wrapper.</span>
<span class="comment">// NEW: Any operator overloads that would create an</span>
<span class="comment">//      expression that does not conform to the</span>
<span class="comment">//      calculator grammar is automatically disabled.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">calculator</span><span class="special">&gt;,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          The only thing we changed is we added <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
          as the second template parameter to the <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> template when defining <code class="computeroutput"><span class="identifier">calculator_domain</span></code>. With this simple addition,
          we disable any of Proto's operator overloads that would create an invalid
          calculator expression.
        </p>
<h6>
<a name="boost_proto.users_guide.getting_started.hello_calculator.h6"></a>
          <span class="phrase"><a name="boost_proto.users_guide.getting_started.hello_calculator.____and_much_more"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator.____and_much_more">...
          And Much More</a>
        </h6>
<p>
          Hopefully, this gives you an idea of what sorts of things Proto can do
          for you. But this only scratches the surface. The rest of this users' guide
          will describe all these features and others in more detail.
        </p>
<p>
          Happy metaprogramming!
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.front_end"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end" title="Fronts Ends: Defining Terminals and Non-Terminals of Your EDSL">Fronts Ends: Defining
      Terminals and Non-Terminals of Your EDSL</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.making_terminals">Making
        Terminals</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads">Proto's
        Operator Overloads</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions">Making
        Lazy Functions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain">Customizing
        Expressions in Your Domain</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.define_operators">Adapting
        Existing Types to Proto</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.code_repetition">Generating
        Repetitive Code with the Preprocessor</a></span></dt>
</dl></div>
<p>
        Here is the fun part: designing your own mini-programming language. In this
        section we'll talk about the nuts and bolts of designing an EDSL interface
        using Proto. We'll cover the definition of terminals and lazy functions that
        the users of your EDSL will get to program with. We'll also talk about Proto's
        expression template-building operator overloads, and about ways to add additional
        members to expressions within your domain.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.making_terminals"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_terminals" title="Making Terminals">Making
        Terminals</a>
</h4></div></div></div>
<p>
          As we saw with the Calculator example from the Introduction, the simplest
          way to get an EDSL up and running is simply to define some terminals, as
          follows.
        </p>
<pre class="programlisting"><span class="comment">// Define a literal integer Proto expression.</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">{</span><span class="number">0</span><span class="special">};</span>

<span class="comment">// This creates an expression template.</span>
<span class="identifier">i</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
          With some terminals and Proto's operator overloads, you can immediately
          start creating expression templates.
        </p>
<p>
          Defining terminals -- with aggregate initialization -- can be a little
          awkward at times. Proto provides an easier-to-use wrapper for literals
          that can be used to construct Protofied terminal expressions. It's called
          <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code>.
        </p>
<pre class="programlisting"><span class="comment">// Define a literal integer Proto expression.</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="comment">// Proto literals are really just Proto terminal expressions.</span>
<span class="comment">// For example, this builds a Proto expression template:</span>
<span class="identifier">i</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
<p>
          There is also a <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code> function for constructing
          a <code class="computeroutput"><a class="link" href="../boost/proto/literal.html" title="Struct template literal">proto::literal&lt;&gt;</a></code> in-place. The above
          expression can simply be written as:
        </p>
<pre class="programlisting"><span class="comment">// proto::lit(0) creates an integer terminal expression</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads" title="Proto's Operator Overloads">Proto's
        Operator Overloads</a>
</h4></div></div></div>
<p>
          Once we have some Proto terminals, expressions involving those terminals
          build expression trees for us. Proto defines overloads for each of C++'s
          overloadable operators in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
          namespace. As long as one operand is a Proto expression, the result of
          the operation is a tree node representing that operation.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            Proto's operator overloads live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
            namespace and are found via ADL (argument-dependent lookup). That is
            why expressions must be "tainted" with Proto-ness for Proto
            to be able to build trees out of expressions.
          </p></td></tr>
</table></div>
<p>
          As a result of Proto's operator overloads, we can say:
        </p>
<pre class="programlisting"><span class="special">-</span><span class="identifier">_1</span><span class="special">;</span>        <span class="comment">// OK, build a unary-negate tree node</span>
<span class="identifier">_1</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span>    <span class="comment">// OK, build a binary-plus tree node</span>
</pre>
<p>
          For the most part, this Just Works and you don't need to think about it,
          but a few operators are special and it can be helpful to know how Proto
          handles them.
        </p>
<h6>
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.assignment__subscript__and_function_call_operators"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads.assignment__subscript__and_function_call_operators">Assignment,
          Subscript, and Function Call Operators</a>
        </h6>
<p>
          Proto also overloads <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>, and <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>, but these operators are member functions
          of the expression template rather than free functions in Proto's namespace.
          The following are valid Proto expressions:
        </p>
<pre class="programlisting"><span class="identifier">_1</span> <span class="special">=</span> <span class="number">5</span><span class="special">;</span>     <span class="comment">// OK, builds a binary assign tree node</span>
<span class="identifier">_1</span><span class="special">[</span><span class="number">6</span><span class="special">];</span>      <span class="comment">// OK, builds a binary subscript tree node</span>
<span class="identifier">_1</span><span class="special">();</span>       <span class="comment">// OK, builds a unary function tree node</span>
<span class="identifier">_1</span><span class="special">(</span><span class="number">7</span><span class="special">);</span>      <span class="comment">// OK, builds a binary function tree node</span>
<span class="identifier">_1</span><span class="special">(</span><span class="number">8</span><span class="special">,</span><span class="number">9</span><span class="special">);</span>    <span class="comment">// OK, builds a ternary function tree node</span>
<span class="comment">// ... etc.</span>
</pre>
<p>
          For the first two lines, assignment and subscript, it should be fairly
          unsurprising that the resulting expression node should be binary. After
          all, there are two operands in each expression. It may be surprising at
          first that what appears to be a function call with no arguments, <code class="computeroutput"><span class="identifier">_1</span><span class="special">()</span></code>,
          actually creates an expression node with one child. The child is <code class="computeroutput"><span class="identifier">_1</span></code> itself. Likewise, the expression
          <code class="computeroutput"><span class="identifier">_1</span><span class="special">(</span><span class="number">7</span><span class="special">)</span></code> has two
          children: <code class="computeroutput"><span class="identifier">_1</span></code> and <code class="computeroutput"><span class="number">7</span></code>.
        </p>
<p>
          Because these operators can only be defined as member functions, the following
          expressions are invalid:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span><span class="special">;</span>
<span class="identifier">i</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">;</span>         <span class="comment">// ERROR: cannot assign _1 to an int</span>

<span class="keyword">int</span> <span class="special">*</span><span class="identifier">p</span><span class="special">;</span>
<span class="identifier">p</span><span class="special">[</span><span class="identifier">_1</span><span class="special">];</span>          <span class="comment">// ERROR: cannot use _1 as an index</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">(</span><span class="identifier">_1</span><span class="special">);</span>   <span class="comment">// ERROR: cannot call std::sin() with _1</span>
</pre>
<p>
          Also, C++ has special rules for overloads of <code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;</span></code> that make it useless for building
          expression templates, so Proto does not overload it.
        </p>
<h6>
<a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.front_end.proto_s_operator_overloads.the_address_of_operator"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.proto_s_operator_overloads.the_address_of_operator">The
          Address-Of Operator</a>
        </h6>
<p>
          Proto overloads the address-of operator for expression types, so that the
          following code creates a new unary address-of tree node:
        </p>
<pre class="programlisting"><span class="special">&amp;</span><span class="identifier">_1</span><span class="special">;</span>    <span class="comment">// OK, creates a unary address-of tree node</span>
</pre>
<p>
          It does <span class="emphasis"><em>not</em></span> return the address of the <code class="computeroutput"><span class="identifier">_1</span></code> object. However, there is special
          code in Proto such that a unary address-of node is implicitly convertible
          to a pointer to its child. In other words, the following code works and
          does what you might expect, but not in the obvious way:
        </p>
<pre class="programlisting"><span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">_1_type</span><span class="special">;</span>

<span class="identifier">_1_type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
<span class="identifier">_1_type</span> <span class="keyword">const</span> <span class="special">*</span> <span class="identifier">p</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">_1</span><span class="special">;</span> <span class="comment">// OK, &amp;_1 implicitly converted</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.making_lazy_functions"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions" title="Making Lazy Functions">Making
        Lazy Functions</a>
</h4></div></div></div>
<p>
          If we limited ourselves to nothing but terminals and operator overloads,
          our embedded domain-specific languages wouldn't be very expressive. Imagine
          that we wanted to extend our calculator EDSL with a full suite of math
          functions like <code class="computeroutput"><span class="identifier">sin</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          that we could invoke lazily as follows.
        </p>
<pre class="programlisting"><span class="comment">// A calculator expression that takes one argument</span>
<span class="comment">// and takes the sine of it.</span>
<span class="identifier">sin</span><span class="special">(</span><span class="identifier">_1</span><span class="special">);</span>
</pre>
<p>
          We would like the above to create an expression template representing a
          function invocation. When that expression is evaluated, it should cause
          the function to be invoked. (At least, that's the meaning of function invocation
          we'd like the calculator EDSL to have.) You can define <code class="computeroutput"><span class="identifier">sin</span></code>
          quite simply as follows.
        </p>
<pre class="programlisting"><span class="comment">// "sin" is a Proto terminal containing a function pointer</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">(*)(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">sin</span> <span class="special">=</span> <span class="special">{&amp;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">};</span>
</pre>
<p>
          In the above, we define <code class="computeroutput"><span class="identifier">sin</span></code>
          as a Proto terminal containing a pointer to the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sin</span><span class="special">()</span></code> function. Now we can use <code class="computeroutput"><span class="identifier">sin</span></code> as a lazy function. The <code class="computeroutput"><span class="identifier">default_context</span></code> that we saw in the Introduction
          knows how to evaluate lazy functions. Consider the following:
        </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">pi</span> <span class="special">=</span> <span class="number">3.1415926535</span><span class="special">;</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_context</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="comment">// Create a lazy "sin" invocation and immediately evaluate it</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(</span> <span class="identifier">sin</span><span class="special">(</span><span class="identifier">pi</span><span class="special">/</span><span class="number">2</span><span class="special">),</span> <span class="identifier">ctx</span> <span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
          The above code prints out:
        </p>
<pre class="programlisting">1</pre>
<p>
          I'm no expert at trigonometry, but that looks right to me.
        </p>
<p>
          We can write <code class="computeroutput"><span class="identifier">sin</span><span class="special">(</span><span class="identifier">pi</span><span class="special">/</span><span class="number">2</span><span class="special">)</span></code> because the <code class="computeroutput"><span class="identifier">sin</span></code>
          object, which is a Proto terminal, has an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code> that builds a node representing a function
          call invocation. The actual type of <code class="computeroutput"><span class="identifier">sin</span><span class="special">(</span><span class="identifier">pi</span><span class="special">/</span><span class="number">2</span><span class="special">)</span></code> is actually
          something like this:
        </p>
<pre class="programlisting"><span class="comment">// The type of the expression sin(pi/2):</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="keyword">double</span><span class="special">(*)(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="special">&amp;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="keyword">const</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;::</span><span class="identifier">type</span>
</pre>
<p>
          This type further expands to an unsightly node type with a <span class="emphasis"><em>tag</em></span>
          type of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code> and two children: the first
          representing the function to be invoked, and the second representing the
          argument to the function. (Node tag types describe the operation that created
          the node. The difference between <code class="computeroutput"><span class="identifier">a</span>
          <span class="special">+</span> <span class="identifier">b</span></code>
          and <code class="computeroutput"><span class="identifier">a</span> <span class="special">-</span>
          <span class="identifier">b</span></code> is that the former has tag
          type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span></code> and the latter has tag type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">minus</span></code>. Tag types are pure compile-time
          information.)
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            In the type computation above, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code> is a metafunction that ensures
            its argument is a Proto expression type. If it isn't one already, it
            becomes a Proto terminal. We'll learn more about this metafunction, along
            with <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>, its runtime counterpart,
            <a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child" title="Controlling How Child Expressions Are Captured">later</a>.
            For now, you can forget about it.
          </p></td></tr>
</table></div>
<p>
          It is important to note that there is nothing special about terminals that
          contain function pointers. <span class="emphasis"><em>Any</em></span> Proto expression has
          an overloaded function call operator. Consider:
        </p>
<pre class="programlisting"><span class="comment">// This compiles!</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="number">1</span><span class="special">)(</span><span class="number">2</span><span class="special">)(</span><span class="number">3</span><span class="special">,</span><span class="number">4</span><span class="special">)(</span><span class="number">5</span><span class="special">,</span><span class="number">6</span><span class="special">,</span><span class="number">7</span><span class="special">,</span><span class="number">8</span><span class="special">);</span>
</pre>
<p>
          That may look strange at first. It creates an integer terminal with <code class="computeroutput"><a class="link" href="../boost/proto/lit.html" title="Function lit">proto::lit()</a></code>, and then invokes it like
          a function again and again. What does it mean? Who knows?! You get to decide
          when you define an evaluation context or a transform. But more on that
          later.
        </p>
<h6>
<a name="boost_proto.users_guide.front_end.making_lazy_functions.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.front_end.making_lazy_functions.making_lazy_functions__continued"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions.making_lazy_functions__continued">Making
          Lazy Functions, Continued</a>
        </h6>
<p>
          Now, what if we wanted to add a <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code> function to our calculator EDSL that
          users could invoke as follows?
        </p>
<pre class="programlisting"><span class="comment">// A calculator expression that takes one argument</span>
<span class="comment">// and raises it to the 2nd power</span>
<span class="identifier">pow</span><span class="special">&lt;</span> <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">);</span>
</pre>
<p>
          The simple technique described above of making <code class="computeroutput"><span class="identifier">pow</span></code>
          a terminal containing a function pointer doesn't work here. If <code class="computeroutput"><span class="identifier">pow</span></code> is an object, then the expression
          <code class="computeroutput"><span class="identifier">pow</span><span class="special">&lt;</span>
          <span class="number">2</span> <span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">)</span></code> is
          not valid C++. (Well, technically it is; it means, <code class="computeroutput"><span class="identifier">pow</span></code>
          less than 2, greater than <code class="computeroutput"><span class="special">(</span><span class="identifier">_1</span><span class="special">)</span></code>,
          which is nothing at all like what we want.) <code class="computeroutput"><span class="identifier">pow</span></code>
          should be a real function template. But it must be an unusual function:
          one that returns an expression template.
        </p>
<p>
          With <code class="computeroutput"><span class="identifier">sin</span></code>, we relied on
          Proto to provide an overloaded <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code> to build an expression node with tag
          type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code> for us. Now we'll need to do
          so ourselves. As before, the node will have two children: the function
          to invoke and the function's argument.
        </p>
<p>
          With <code class="computeroutput"><span class="identifier">sin</span></code>, the function
          to invoke was a raw function pointer wrapped in a Proto terminal. In the
          case of <code class="computeroutput"><span class="identifier">pow</span></code>, we want it
          to be a terminal containing TR1-style function object. This will allow
          us to parameterize the function on the exponent. Below is the implementation
          of a simple TR1-style wrapper for the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pow</span></code>
          function:
        </p>
<pre class="programlisting"><span class="comment">// Define a pow_fun function object</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="identifier">Exp</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">pow_fun</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="keyword">double</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">double</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pow</span><span class="special">(</span><span class="identifier">d</span><span class="special">,</span> <span class="identifier">Exp</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          Following the <code class="computeroutput"><span class="identifier">sin</span></code> example,
          we want <code class="computeroutput"><span class="identifier">pow</span><span class="special">&lt;</span>
          <span class="number">1</span> <span class="special">&gt;(</span>
          <span class="identifier">pi</span><span class="special">/</span><span class="number">2</span> <span class="special">)</span></code> to have
          a type like this:
        </p>
<pre class="programlisting"><span class="comment">// The type of the expression pow&lt;1&gt;(pi/2):</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="keyword">const</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;::</span><span class="identifier">type</span>
</pre>
<p>
          We could write a <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          function using code like this, but it's verbose and error prone; it's too
          easy to introduce subtle bugs by forgetting to call <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
          where necessary, resulting in code that seems to work but sometimes doesn't.
          Proto provides a better way to construct expression nodes: <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>.
        </p>
<h6>
<a name="boost_proto.users_guide.front_end.making_lazy_functions.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.front_end.making_lazy_functions.lazy_functions_made_simple_with__literal_make_expr____literal_"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.making_lazy_functions.lazy_functions_made_simple_with__literal_make_expr____literal_">Lazy
          Functions Made Simple With <code class="literal">make_expr()</code></a>
        </h6>
<p>
          Proto provides a helper for building expression templates called <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>. We can concisely define
          the <code class="computeroutput"><span class="identifier">pow</span><span class="special">()</span></code>
          function with it as below.
        </p>
<pre class="programlisting"><span class="comment">// Define a lazy pow() function for the calculator EDSL.</span>
<span class="comment">// Can be used as: pow&lt; 2 &gt;(_1)</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="identifier">Exp</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Arg</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span>  <span class="comment">// Tag type</span>
  <span class="special">,</span> <span class="identifier">pow_fun</span><span class="special">&lt;</span> <span class="identifier">Exp</span> <span class="special">&gt;</span>        <span class="comment">// First child (by value)</span>
  <span class="special">,</span> <span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span>           <span class="comment">// Second child (by reference)</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span>
<span class="identifier">pow</span><span class="special">(</span><span class="identifier">Arg</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">arg</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">&gt;(</span>
        <span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;()</span>    <span class="comment">// First child (by value)</span>
      <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">arg</span><span class="special">)</span>   <span class="comment">// Second child (by reference)</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          There are some things to notice about the above code. We use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code>
          to calculate the return type. The first template parameter is the tag type
          for the expression node we're building -- in this case, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span></code>.
        </p>
<p>
          Subsequent template parameters to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;&gt;</span></code> represent child nodes. If a child
          type is not already a Proto expression, it is automatically made into a
          terminal with <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>.
          A type such as <code class="computeroutput"><span class="identifier">pow_fun</span><span class="special">&lt;</span><span class="identifier">Exp</span><span class="special">&gt;</span></code> results in terminal that is held by
          value, whereas a type like <code class="computeroutput"><span class="identifier">Arg</span>
          <span class="keyword">const</span> <span class="special">&amp;</span></code>
          (note the reference) indicates that the result should be held by reference.
        </p>
<p>
          In the function body is the runtime invocation of <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>.
          It closely mirrors the return type calculation. <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>
          requires you to specify the node's tag type as a template parameter. The
          arguments to the function become the node's children. When a child should
          be stored by value, nothing special needs to be done. When a child should
          be stored by reference, you must use the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">()</span></code> function to wrap the argument.
        </p>
<p>
          And that's it! <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>
          is the lazy person's way to make a lazy funtion.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain" title="Customizing Expressions in Your Domain">Customizing
        Expressions in Your Domain</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.domains">Domains</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends">The
          <code class="literal">extends&lt;&gt;</code> Expression Wrapper</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.expression_generators">Expression
          Generators</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.inhibiting_overloads">Controlling
          Operator Overloads</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child">Controlling
          How Child Expressions Are Captured</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains">EDSL
          Interoperatability: Sub-Domains</a></span></dt>
</dl></div>
<p>
          In this section, we'll learn all about <span class="emphasis"><em>domains</em></span>. In
          particular, we'll learn:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              How to associate Proto expressions with a domain,
            </li>
<li class="listitem">
              How to add members to expressions within a domain,
            </li>
<li class="listitem">
              How to use a <span class="emphasis"><em>generator</em></span> to post-process all new
              expressions created in your domain,
            </li>
<li class="listitem">
              How to control which operators are overloaded in a domain,
            </li>
<li class="listitem">
              How to specify capturing policies for child expressions and non-Proto
              objects, and
            </li>
<li class="listitem">
              How to make expressions from separate domains interoperate.
            </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.domains"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.domains" title="Domains">Domains</a>
</h5></div></div></div>
<p>
            In the <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> section, we looked into making calculator expressions
            directly usable as lambda expressions in calls to STL algorithms, as
            below:
          </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">1.</span><span class="special">,</span> <span class="number">2.</span><span class="special">,</span> <span class="number">3.</span><span class="special">,</span> <span class="number">4.</span><span class="special">};</span>

<span class="comment">// Use the calculator EDSL to square each element ... HOW?</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_1</span> <span class="special">);</span>
</pre>
<p>
            The difficulty, if you recall, was that by default Proto expressions
            don't have interesting behaviors of their own. They're just trees. In
            particular, the expression <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">*</span> <span class="identifier">_1</span></code>
            won't have an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            that takes a double and returns a double like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">()</span></code> expects -- unless we give it one. To
            make this work, we needed to define an expression wrapper type that defined
            the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            member function, and we needed to associate the wrapper with the calculator
            <span class="emphasis"><em>domain</em></span>.
          </p>
<p>
            In Proto, the term <span class="emphasis"><em>domain</em></span> refers to a type that
            associates expressions in that domain to an expression <span class="emphasis"><em>generator</em></span>.
            The generator is just a function object that accepts an expression and
            does something to it, like wrapping it in an expression wrapper.
          </p>
<p>
            You can also use a domain to associate expressions with a grammar. When
            you specify a domain's grammar, Proto ensures that all the expressions
            it generates in that domain conform to the domain's grammar. It does
            that by disabling any operator overloads that would create invalid expressions.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends" title="The extends&lt;&gt; Expression Wrapper">The
          <code class="literal">extends&lt;&gt;</code> Expression Wrapper</a>
</h5></div></div></div>
<p>
            The first step to giving your calculator expressions extra behaviors
            is to define a calculator domain. All expressions within the calculator
            domain will be imbued with calculator-ness, as we'll see.
          </p>
<pre class="programlisting"><span class="comment">// A type to be used as a domain tag (to be defined below)</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span><span class="special">;</span>
</pre>
<p>
            We use this domain type when extending the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
            type, which we do with the <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            class template. Here is our expression wrapper, which imbues an expression
            with calculator-ness. It is described below.
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span> <span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">Expr</span> <span class="special">&gt;,</span> <span class="identifier">calculator_domain</span> <span class="special">&gt;</span>
    <span class="identifier">base_type</span><span class="special">;</span>

    <span class="identifier">calculator</span><span class="special">(</span> <span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">Expr</span><span class="special">()</span> <span class="special">)</span>
      <span class="special">:</span> <span class="identifier">base_type</span><span class="special">(</span> <span class="identifier">expr</span> <span class="special">)</span>
    <span class="special">{}</span>

    <span class="comment">// This is usually needed because by default, the compiler-</span>
    <span class="comment">// generated assignment operator hides extends&lt;&gt;::operator=</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_USING_ASSIGN</span><span class="special">(</span><span class="identifier">calculator</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="comment">// Hide base_type::operator() by defining our own which</span>
    <span class="comment">// evaluates the calculator expression with a calculator context.</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// As defined in the Hello Calculator section.</span>
        <span class="identifier">calculator_context</span> <span class="identifier">ctx</span><span class="special">;</span>

        <span class="comment">// ctx.args is a vector&lt;double&gt; that holds the values</span>
        <span class="comment">// with which we replace the placeholders (e.g., _1 and _2)</span>
        <span class="comment">// in the expression.</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d1</span> <span class="special">);</span> <span class="comment">// _1 gets the value of d1</span>
        <span class="identifier">ctx</span><span class="special">.</span><span class="identifier">args</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">d2</span> <span class="special">);</span> <span class="comment">// _2 gets the value of d2</span>

        <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">eval</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">ctx</span> <span class="special">);</span> <span class="comment">// evaluate the expression</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            We want calculator expressions to be function objects, so we have to
            define an <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            that takes and returns doubles. The <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper above does that with
            the help of the <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            template. The first template to <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            parameter is the expression type we are extending. The second is the
            type of the wrapped expression. The third parameter is the domain that
            this wrapper is associated with. A wrapper type like <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> that inherits from <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code> behaves just like
            the expression type it has extended, with any additional behaviors you
            choose to give it.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Why not just inherit from <code class="literal">proto::expr&lt;&gt;</code>?</strong></span>
            </p>
<p>
              You might be thinking that this expression extension business is unnecessarily
              complicated. After all, isn't this why C++ supports inheritance? Why
              can't <code class="literal">calculator&lt;Expr&gt;</code> just inherit from
              <code class="literal">Expr</code> directly? The reason is because <code class="literal">Expr</code>,
              which presumably is an instantiation of <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>,
              has expression template-building operator overloads that will be incorrect
              for derived types. They will store <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by reference to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code>, effectively slicing off any
              derived parts. <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
              gives your derived types operator overloads that don't slice off your
              additional members.
            </p>
</td></tr>
</table></div>
<p>
            Although not strictly necessary in this case, we bring <code class="computeroutput"><span class="identifier">extends</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            into scope with the <code class="computeroutput"><span class="identifier">BOOST_PROTO_EXTENDS_USING_ASSIGN</span><span class="special">()</span></code> macro. This is really only necessary
            if you want expressions like <code class="computeroutput"><span class="identifier">_1</span>
            <span class="special">=</span> <span class="number">3</span></code>
            to create a lazily evaluated assignment. <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
            defines the appropriate <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code> for you, but the compiler-generated
            <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">=</span></code>
            will hide it unless you make it available with the macro.
          </p>
<p>
            Note that in the implementation of <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;::</span><span class="keyword">operator</span><span class="special">()</span></code>, we evaluate the expression with the
            <code class="computeroutput"><span class="identifier">calculator_context</span></code> we
            defined earlier. As we saw before, the context is what gives the operators
            their meaning. In the case of the calculator, the context is also what
            defines the meaning of the placeholder terminals.
          </p>
<p>
            Now that we have defined the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> expression wrapper, we need to
            wrap the placeholders to imbue them with calculator-ness:
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span><span class="special">;</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span><span class="special">;</span>
</pre>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.h0"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.retaining_pod_ness_with__literal_boost_proto_extends____literal_">Retaining
            POD-ness with <code class="literal">BOOST_PROTO_EXTENDS()</code></a>
          </h6>
<p>
            To use <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>, your extension type
            must derive from <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>.
            Unfortunately, that means that your extension type is no longer POD and
            its instances cannot be <span class="emphasis"><em>statically initialized</em></span>.
            (See the <a class="link" href="appendices.html#boost_proto.appendices.rationale.static_initialization" title="Static Initialization">Static
            Initialization</a> section in the <a class="link" href="appendices.html#boost_proto.appendices.rationale" title="Appendix C: Rationale">Rationale</a>
            appendix for why this matters.) In particular, as defined above, the
            global placeholder objects <code class="computeroutput"><span class="identifier">_1</span></code>
            and <code class="computeroutput"><span class="identifier">_2</span></code> will need to be
            initialized at runtime, which could lead to subtle order of initialization
            bugs.
          </p>
<p>
            There is another way to make an expression extension that doesn't sacrifice
            POD-ness : the <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            macro. You can use it much like you use <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>.
            We can use <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            to keep <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code>
            a POD and our placeholders statically initialized.
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_EXTENDS() instead of proto::extends&lt;&gt; to</span>
    <span class="comment">// make this type a Proto expression extension.</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            With the new <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type, we can redefine our placeholders
            to be statically initialized:
          </p>
<pre class="programlisting"><span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{{}}};</span>
<span class="identifier">calculator</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">_2</span> <span class="special">=</span> <span class="special">{{{}}};</span>
</pre>
<p>
            We need to make one additional small change to accommodate the POD-ness
            of our expression extension, which we'll describe below in the section
            on expression generators.
          </p>
<p>
            What does <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            do? It defines a data member of the expression type being extended; some
            nested typedefs that Proto requires; <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code> and <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> overloads for building expression templates;
            and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template for calculating the return type of <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>. In this case, however, the <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>
            overloads and the <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code> template are not needed because
            we are defining our own <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> in the <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type. Proto provides additional
            macros for finer control over which member functions are defined. We
            could improve our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> type as follows:
          </p>
<pre class="programlisting"><span class="comment">// The calculator&lt;&gt; expression wrapper makes expressions</span>
<span class="comment">// function objects.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Expr</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">calculator</span>
<span class="special">{</span>
    <span class="comment">// Use BOOST_PROTO_BASIC_EXTENDS() instead of proto::extends&lt;&gt; to</span>
    <span class="comment">// make this type a Proto expression extension:</span>
    <span class="identifier">BOOST_PROTO_BASIC_EXTENDS</span><span class="special">(</span><span class="identifier">Expr</span><span class="special">,</span> <span class="identifier">calculator</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;,</span> <span class="identifier">calculator_domain</span><span class="special">)</span>

    <span class="comment">// Define operator[] to build expression templates:</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_SUBSCRIPT</span><span class="special">()</span>

    <span class="comment">// Define operator= to build expression templates:</span>
    <span class="identifier">BOOST_PROTO_EXTENDS_ASSIGN</span><span class="special">()</span>

    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="keyword">double</span> <span class="identifier">d1</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d2</span> <span class="special">=</span> <span class="number">0.0</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">/* ... as before ... */</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Notice that we are now using <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>
            instead of <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>.
            This just adds the data member and the nested typedefs but not any of
            the overloaded operators. Those are added separately with <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>
            and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_7.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>.
            We are leaving out the function call operator and the nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
            template that could have been defined with Proto's <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_6.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code>
            macro.
          </p>
<p>
            In summary, here are the macros you can use to define expression extensions,
            and a brief description of each.
          </p>
<div class="table">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.extends.t0"></a><p class="title"><b>Table 31.2. Expression Extension Macros</b></p>
<div class="table-contents"><table class="table" summary="Expression Extension Macros">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Macro
                    </p>
                  </th>
<th>
                    <p>
                      Purpose
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                    </p>
                  </td>
<td>
                    <p>
                      Defines a data member of type <code class="computeroutput"><em class="replaceable"><code>expression</code></em></code>
                      and some nested typedefs that Proto requires.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">=</span></code>. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_7.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_6.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code>
                    </p>
                  </td>
<td>
                    <p>
                      Defines <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> and a nested <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
                      template for return type calculation. Only valid when preceded
                      by <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code>()</code>.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code><span class="special">(</span>
    <em class="replaceable"><code>expression</code></em>
  <span class="special">,</span> <em class="replaceable"><code>extension</code></em>
  <span class="special">,</span> <em class="replaceable"><code>domain</code></em>
<span class="special">)</span></pre>
<p>
                    </p>
                  </td>
<td>
                    <p>
                      Equivalent to:
</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_BASIC_EXTENDS.html" title="Macro BOOST_PROTO_BASIC_EXTENDS">BOOST_PROTO_BASIC_EXTENDS</a></code><span class="special">(</span><em class="replaceable"><code>expression</code></em><span class="special">,</span> <em class="replaceable"><code>extension</code></em><span class="special">,</span> <em class="replaceable"><code>domain</code></em><span class="special">)</span>

  <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS_ASSIGN.html" title="Macro BOOST_PROTO_EXTENDS_ASSIGN">BOOST_PROTO_EXTENDS_ASSIGN</a></code>()</code>

  <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_7.html" title="Macro BOOST_PROTO_EXTENDS_SUBSCRIPT">BOOST_PROTO_EXTENDS_SUBSCRIPT</a></code>()</code>

  <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_10_6.html" title="Macro BOOST_PROTO_EXTENDS_FUNCTION">BOOST_PROTO_EXTENDS_FUNCTION</a></code>()</code></pre>
<p>
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
              <span class="bold"><strong>Argument-Dependent Lookup and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code></strong></span>
            </p>
<p>
              Proto's operator overloads are defined in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace and are found by argument-dependent lookup (ADL). This usually
              just works because expressions are made up of types that live in the
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> namespace. However, sometimes
              when you use <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
              that is not the case. Consider:
            </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_complex</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span>
    <span class="special">)</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">c0</span><span class="special">,</span> <span class="identifier">c1</span><span class="special">;</span>

    <span class="identifier">c0</span> <span class="special">+</span> <span class="identifier">c1</span><span class="special">;</span> <span class="comment">// ERROR: operator+ not found</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
              The problem has to do with how argument-dependent lookup works. The
              type <code class="computeroutput"><span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>
              is not associated in any way with the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace, so the operators defined there are not considered. (Had
              we inherited from <code class="computeroutput"><a class="link" href="../boost/proto/extends.html" title="Struct template extends">proto::extends&lt;&gt;</a></code>
              instead of used <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>,
              we would have avoided the problem because inheriting from a type in
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> namespace is enough to get
              ADL to kick in.)
            </p>
<p>
              So what can we do? By adding an extra dummy template parameter that
              defaults to a type in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code>
              namespace, we can trick ADL into finding the right operator overloads.
              The solution looks like this:
            </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Dummy</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">is_proto_expr</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_complex</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span>
        <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">,</span> <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span>
    <span class="special">)</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">c0</span><span class="special">,</span> <span class="identifier">c1</span><span class="special">;</span>

    <span class="identifier">c0</span> <span class="special">+</span> <span class="identifier">c1</span><span class="special">;</span> <span class="comment">// OK, operator+ found now!</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
              The type <code class="computeroutput"><a class="link" href="../boost/proto/is_proto_expr.html" title="Struct is_proto_expr">proto::is_proto_expr</a></code> is nothing
              but an empty struct, but by making it a template parameter we make
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span></code> an associated namespace of
              <code class="computeroutput"><span class="identifier">my_complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>.
              Now ADL can successfully find Proto's operator overloads.
            </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.expression_generators"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.expression_generators" title="Expression Generators">Expression
          Generators</a>
</h5></div></div></div>
<p>
            The last thing that remains to be done is to tell Proto that it needs
            to wrap all of our calculator expressions in our <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> wrapper. We have already wrapped
            the placeholders, but we want <span class="emphasis"><em>all</em></span> expressions that
            involve the calculator placeholders to be calculators. We can do that
            by specifying an expression generator when we define our <code class="computeroutput"><span class="identifier">calculator_domain</span></code>, as follows:
          </p>
<pre class="programlisting"><span class="comment">// Define the calculator_domain we forward-declared above.</span>
<span class="comment">// Specify that all expression in this domain should be wrapped</span>
<span class="comment">// in the calculator&lt;&gt; expression wrapper.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The first template parameter to <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> is the generator. "Generator"
            is just a fancy name for a function object that accepts an expression
            and does something to it. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code> is a very simple one --- it wraps
            an expression in the wrapper you specify. <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;&gt;</span></code> inherits from its generator parameter,
            so all domains are themselves function objects.
          </p>
<p>
            If we used <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_EXTENDS.html" title="Macro BOOST_PROTO_EXTENDS">BOOST_PROTO_EXTENDS</a></code>()</code>
            to keep our expression extension type POD, then we need to use <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;&gt;</span></code>
            instead of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;&gt;</span></code>,
            as follows:
          </p>
<pre class="programlisting"><span class="comment">// If calculator&lt;&gt; uses BOOST_PROTO_EXTENDS() instead of </span>
<span class="comment">// use proto::extends&lt;&gt;, use proto::pod_generator&lt;&gt; instead</span>
<span class="comment">// of proto::generator&lt;&gt;.</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            After Proto has calculated a new expression type, it checks the domains
            of the child expressions. They must match. Assuming they do, Proto creates
            the new expression and passes it to <code class="computeroutput"><em class="replaceable"><code>Domain</code></em><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> for any additional processing. If we
            don't specify a generator, the new expression gets passed through unchanged.
            But since we've specified a generator above, <code class="computeroutput"><span class="identifier">calculator_domain</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="identifier">calculator</span><span class="special">&lt;&gt;</span></code> objects.
          </p>
<p>
            Now we can use calculator expressions as function objects to STL algorithms,
            as follows:
          </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">1.</span><span class="special">,</span> <span class="number">2.</span><span class="special">,</span> <span class="number">3.</span><span class="special">,</span> <span class="number">4.</span><span class="special">};</span>

<span class="comment">// Use the calculator EDSL to square each element ... WORKS! :-)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">_1</span> <span class="special">*</span> <span class="identifier">_1</span> <span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.inhibiting_overloads"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.inhibiting_overloads" title="Controlling Operator Overloads">Controlling
          Operator Overloads</a>
</h5></div></div></div>
<p>
            By default, Proto defines every possible operator overload for Protofied
            expressions. This makes it simple to bang together an EDSL. In some cases,
            however, the presence of Proto's promiscuous overloads can lead to confusion
            or worse. When that happens, you'll have to disable some of Proto's overloaded
            operators. That is done by defining the grammar for your domain and specifying
            it as the second parameter of the <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            template.
          </p>
<p>
            In the <a class="link" href="users_guide.html#boost_proto.users_guide.getting_started.hello_calculator" title="Hello Calculator">Hello
            Calculator</a> section, we saw an example of a Proto grammar, which
            is repeated here:
          </p>
<pre class="programlisting"><span class="comment">// Define the grammar of calculator expressions</span>
<span class="keyword">struct</span> <span class="identifier">calculator_grammar</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">or_</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">plus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">minus</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">divides</span><span class="special">&lt;</span> <span class="identifier">calculator_grammar</span><span class="special">,</span> <span class="identifier">calculator_grammar</span> <span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            We'll have much more to say about grammars in subsequent sections, but
            for now, we'll just say that the <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            struct describes a subset of all expression types -- the subset that
            comprise valid calculator expressions. We would like to prohibit Proto
            from creating a calculator expression that does not conform to this grammar.
            We do that by changing the definition of the <code class="computeroutput"><span class="identifier">calculator_domain</span></code>
            struct.
          </p>
<pre class="programlisting"><span class="comment">// Define the calculator_domain. Expressions in the calculator</span>
<span class="comment">// domain are wrapped in the calculator&lt;&gt; wrapper, and they must</span>
<span class="comment">// conform to the calculator_grammar:</span>
<span class="keyword">struct</span> <span class="identifier">calculator_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">calculator</span> <span class="special">&gt;,</span> <span class="bold"><strong>calculator_grammar</strong></span>  <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The only new addition is <code class="computeroutput"><span class="identifier">calculator_grammar</span></code>
            as the second template parameter to the <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            template. That has the effect of disabling any of Proto's operator overloads
            that would create an invalid calculator expression.
          </p>
<p>
            Another common use for this feature would be to disable Proto's unary
            <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            overload. It may be surprising for users of your EDSL that they cannot
            take the address of their expressions! You can very easily disable Proto's
            unary <code class="computeroutput"><span class="keyword">operator</span><span class="special">&amp;</span></code>
            overload for your domain with a very simple grammar, as below:
          </p>
<pre class="programlisting"><span class="comment">// For expressions in my_domain, disable Proto's</span>
<span class="comment">// unary address-of operator.</span>
<span class="keyword">struct</span> <span class="identifier">my_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span> <span class="identifier">my_wrapper</span> <span class="special">&gt;</span>
        <span class="comment">// A simple grammar that matches any expression that</span>
        <span class="comment">// is not a unary address-of expression.</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;</span> <span class="identifier">_</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The type <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">address_of</span><span class="special">&lt;</span>
            <span class="identifier">_</span> <span class="special">&gt;</span>
            <span class="special">&gt;</span></code> is a very simple grammar
            that matches all expressions except unary address-of expressions. In
            the section describing Proto's intermediate form, we'll have much more
            to say about grammars.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child" title="Controlling How Child Expressions Are Captured">Controlling
          How Child Expressions Are Captured</a>
</h5></div></div></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              This is an advanced topic. Feel free to skip this if you're just getting
              started with Proto.
            </p></td></tr>
</table></div>
<p>
            Proto's operator overloads build expressions from sub-expressions. The
            sub-expressions become children of the new expression. By default, the
            children are stored in the parent by reference. This section describes
            how to change that default.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.h0"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.primer___literal_as_child__literal__vs___literal_as_expr__literal_"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.primer___literal_as_child__literal__vs___literal_as_expr__literal_">Primer:
            <code class="literal">as_child</code> vs. <code class="literal">as_expr</code></a>
          </h6>
<p>
            Proto lets you independently customize the behavior of <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code> and <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code>.
            Both accept an object <code class="literal">x</code> and return a Proto expression
            by turning <code class="literal">x</code> it into a Proto terminal if necessary.
            Although similar, the two functions are used in different situations
            and have subtly different behavior by default. It's important to understand
            the difference so that you know which to customize to achieve the behavior
            you want.
          </p>
<p>
            To wit: <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code> is typically used by
            <span class="emphasis"><em>you</em></span> to turn an object into a Proto expression that
            is to be held in a local variable, as so:
          </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">l</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span> <span class="comment">// Turn x into a Proto expression, hold the result in a local</span>
</pre>
<p>
            The above works regardless of whether <code class="computeroutput"><span class="identifier">x</span></code>
            is already a Proto expression or not. The object <code class="computeroutput"><span class="identifier">l</span></code>
            is guaranteed to be a valid Proto expression. If <code class="computeroutput"><span class="identifier">x</span></code>
            is a non-Proto object, it is turned into a terminal expression that holds
            <code class="computeroutput"><span class="identifier">x</span></code> <span class="emphasis"><em>by value</em></span>.<a href="#ftn.boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.f0" class="footnote" name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.f0"><sup class="footnote">[33]</sup></a> If <code class="computeroutput"><span class="identifier">x</span></code> is a
            Proto object already, <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code>
            returns it <span class="emphasis"><em>by value</em></span> unmodified.
          </p>
<p>
            In contrast, <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
            is used internally by Proto to pre-process objects before making them
            children of another expression. Since it's internal to Proto, you don't
            see it explicitly, but it's there behind the scenes in expressions like
            this:
          </p>
<pre class="programlisting"><span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">;</span> <span class="comment">// Consider that y is a Proto expression, but x may or may not be.</span>
</pre>
<p>
            In this case, Proto builds a plus node from the two children. Both are
            pre-processed by passing them to <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
            before making them children of the new node. If <code class="computeroutput"><span class="identifier">x</span></code>
            is not a Proto expression, it becomes one by being wrapped in a Proto
            terminal that holds it <span class="emphasis"><em>by reference</em></span>. If <code class="computeroutput"><span class="identifier">x</span></code> is already a Proto expression, <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code> returns it <span class="emphasis"><em>by
            reference</em></span> unmodified. Contrast this with the above description
            for <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code>.
          </p>
<p>
            The table below summarizes the above description.
          </p>
<div class="table">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.t0"></a><p class="title"><b>Table 31.3. proto::as_expr() vs. proto::as_child()</b></p>
<div class="table-contents"><table class="table" summary="proto::as_expr() vs. proto::as_child()">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      <span class="bold"><strong>Function</strong></span>
                    </p>
                  </th>
<th>
                    <p>
                      <span class="bold"><strong>When <code class="literal">t</code> is not a Proto
                      expr...</strong></span>
                    </p>
                  </th>
<th>
                    <p>
                      <span class="bold"><strong>When <code class="literal">t</code> is a Proto
                      expr...</strong></span>
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      <code class="literal">proto::as_expr(t)</code>
                    </p>
                  </td>
<td>
                    <p>
                      Return (by value) a new Proto terminal holding <code class="literal">t</code>
                      by value.
                    </p>
                  </td>
<td>
                    <p>
                      Return <code class="literal">t</code> by value unmodified.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="literal">proto::as_child(t)</code>
                    </p>
                  </td>
<td>
                    <p>
                      Return (by value) a new Proto terminal holding <code class="literal">t</code>
                      by reference.
                    </p>
                  </td>
<td>
                    <p>
                      Return <code class="literal">t</code> by reference unmodified.
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              There is one important place where Proto uses both <code class="computeroutput"><span class="identifier">as_expr</span></code>
              <span class="emphasis"><em>and</em></span> <code class="computeroutput"><span class="identifier">as_child</span></code>:
              <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code>. The <code class="computeroutput"><a class="link" href="../boost/proto/make_expr.html" title="Function make_expr">proto::make_expr()</a></code> function requires
              you to specify for each child whether it should be held by value or
              by reference. Proto uses <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code>
              to pre-process the children to be held by value, and <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code> for the ones to be
              held by reference.
            </p></td></tr>
</table></div>
<p>
            Now that you know what <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
            and <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code> are, where they are
            used, and what they do by default, you may decide that one or both of
            these functions should have different behavior for your domain. For instance,
            given the above description of <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>,
            the following code is always wrong:
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">l</span> <span class="special">=</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span> <span class="comment">// This is WRONG! Don't do this.</span>
</pre>
<p>
            Why is this wrong? Because <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
            will turn the integer literal 42 into a Proto terminal that holds a reference
            to a temporary integer initialized with 42. The lifetime of that temporary
            ends at the semicolon, guaranteeing that the local <code class="computeroutput"><span class="identifier">l</span></code>
            is left holding a dangling reference to a deceased integer. What to do?
            One answer is to use <code class="computeroutput"><a class="link" href="../boost/proto/deep_copy.html" title="Function template deep_copy">proto::deep_copy()</a></code>.
            Another is to customize the behavior of <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>
            for your domain. Read on for the details.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.h1"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.per_domain__literal_as_child__literal_"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.per_domain__literal_as_child__literal_">Per-Domain
            <code class="literal">as_child</code></a>
          </h6>
<p>
            To control how Proto builds expressions out of sub-expressions in your
            domain, define your domain as usual, and then define a nested <code class="computeroutput"><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code>
            class template within it, as follows:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">my_generator</span><span class="special">,</span> <span class="identifier">my_grammar</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// Here is where you define how Proto should handle</span>
    <span class="comment">// sub-expressions that are about to be glommed into</span>
    <span class="comment">// a larger expression.</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">as_child</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="emphasis"><em><code class="literal">unspecified-Proto-expr-type</code></em></span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">T</span> <span class="special">&amp;</span> <span class="identifier">t</span> <span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="emphasis"><em><code class="literal">unspecified-Proto-expr-object</code></em></span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
            There's one important thing to note: in the above code, the template
            parameter <code class="literal">T</code> may or may not be a Proto expression type,
            but the result <span class="emphasis"><em>must</em></span> be a Proto expression type,
            or a reference to one. That means that most user-defined <code class="literal">as_child&lt;&gt;</code>
            templates will need to check whether <code class="literal">T</code> is an expression
            or not (using <code class="computeroutput"><a class="link" href="../boost/proto/is_expr.html" title="Struct template is_expr">proto::is_expr&lt;&gt;</a></code>), and then turn non-expressions
            into Proto terminals by wrapping them as <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="comment">/* ... */</span>
            <span class="special">&gt;::</span><span class="identifier">type</span></code>
            or equivalent.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.h2"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.per_domain__literal_as_expr__literal_"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.per_domain__literal_as_expr__literal_">Per-Domain
            <code class="literal">as_expr</code></a>
          </h6>
<p>
            Although less common, Proto also lets you customize the behavior of
            <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code> on a per-domain basis.
            The technique is identical to that for <code class="literal">as_child</code>. See
            below:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">my_generator</span><span class="special">,</span> <span class="identifier">my_grammar</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// Here is where you define how Proto should handle</span>
    <span class="comment">// objects that are to be turned into expressions</span>
    <span class="comment">// fit for storage in local variables.</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">as_expr</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="emphasis"><em><code class="literal">unspecified-Proto-expr-type</code></em></span> <span class="identifier">result_type</span><span class="special">;</span>

        <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">T</span> <span class="special">&amp;</span> <span class="identifier">t</span> <span class="special">)</span> <span class="keyword">const</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="emphasis"><em><code class="literal">unspecified-Proto-expr-object</code></em></span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.h3"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.making_proto_expressions__literal_auto__literal__safe"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.per_domain_as_child.making_proto_expressions__literal_auto__literal__safe">Making
            Proto Expressions <code class="literal">auto</code>-safe</a>
          </h6>
<p>
            Let's look again at the problem described above involving the C++11
            <code class="computeroutput"><span class="keyword">auto</span></code> keyword and the default
            behavior of <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code>.
          </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">l</span> <span class="special">=</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span> <span class="comment">// This is WRONG! Don't do this.</span>
</pre>
<p>
            Recall that the problem is the lifetime of the temporary integer created
            to hold the value 42. The local <code class="computeroutput"><span class="identifier">l</span></code>
            will be left holding a dangling reference to it after its lifetime is
            over. What if we want Proto to make expressions safe to store this way
            in local variables? We can do so very easily by making <code class="computeroutput"><a class="link" href="../boost/proto/as_child.html" title="Function as_child">proto::as_child()</a></code> behave just like <code class="computeroutput"><a class="link" href="../boost/proto/as_expr.html" title="Function as_expr">proto::as_expr()</a></code>. The following code
            achieves this:
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">E</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_expr</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">my_generator</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">pod_generator</span><span class="special">&lt;</span> <span class="identifier">my_expr</span> <span class="special">&gt;</span>
<span class="special">{};</span>

<span class="keyword">struct</span> <span class="identifier">my_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span> <span class="identifier">my_generator</span> <span class="special">&gt;</span>
<span class="special">{</span>
     <span class="comment">// Make as_child() behave like as_expr() in my_domain.</span>
     <span class="comment">// (proto_base_domain is a typedef for proto::domain&lt; my_generator &gt;</span>
     <span class="comment">// that is defined in proto::domain&lt;&gt;.)</span>
     <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
     <span class="keyword">struct</span> <span class="identifier">as_child</span>
       <span class="special">:</span> <span class="identifier">proto_base_domain</span><span class="special">::</span><span class="identifier">as_expr</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span>
     <span class="special">{};</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">E</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">my_expr</span>
<span class="special">{</span>
    <span class="identifier">BOOST_PROTO_EXTENDS</span><span class="special">(</span> <span class="identifier">E</span><span class="special">,</span> <span class="identifier">my_expr</span><span class="special">&lt;</span> <span class="identifier">E</span> <span class="special">&gt;,</span> <span class="identifier">my_domain</span> <span class="special">)</span>
<span class="special">};</span>

<span class="comment">/* ... */</span>

<span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">my_domain</span> <span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">l</span> <span class="special">=</span> <span class="identifier">i</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span> <span class="comment">// OK! Everything is stored by value here.</span>
</pre>
<p>
            Notice that <code class="computeroutput"><span class="identifier">my_domain</span><span class="special">::</span><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code> simply defers to the default
            implementation of <code class="computeroutput"><span class="identifier">as_expr</span><span class="special">&lt;&gt;</span></code> found in <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>.
            By simply cross-wiring our domain's <code class="computeroutput"><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code> to <code class="computeroutput"><span class="identifier">as_expr</span><span class="special">&lt;&gt;</span></code>, we guarantee that all terminals
            that can be held by value are, and that all child expressions are also
            held by value. This increases copying and may incur a runtime performance
            cost, but it eliminates any spector of lifetime management issues.
          </p>
<p>
            For another example, see the definition of <code class="computeroutput"><span class="identifier">lldomain</span></code>
            in <code class="literal">libs/proto/example/lambda.hpp</code>. That example is
            a complete reimplementation of the Boost Lambda Library (BLL) on top
            of Boost.Proto. The function objects the BLL generates are safe to be
            stored in local variables. To emulate this with Proto, the <code class="computeroutput"><span class="identifier">lldomain</span></code> cross-wires <code class="computeroutput"><span class="identifier">as_child</span><span class="special">&lt;&gt;</span></code>
            to <code class="computeroutput"><span class="identifier">as_expr</span><span class="special">&lt;&gt;</span></code>
            as above, but with one extra twist: objects with array type are also
            stored by reference. Check it out.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains" title="EDSL Interoperatability: Sub-Domains">EDSL
          Interoperatability: Sub-Domains</a>
</h5></div></div></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              This is an advanced topic. Feel free to skip this if you're just getting
              started with Proto.
            </p></td></tr>
</table></div>
<p>
            The ability to <span class="emphasis"><em>compose</em></span> different EDSLs is one of
            their most exciting features. Consider how you build a parser using yacc.
            You write your grammar rules in yacc's domain-specific language. Then
            you embed semantic actions written in C within your grammar. Boost's
            Spirit parser generator gives you the same ability. You write grammar
            rules using Spirit.Qi and embed semantic actions using the Phoenix library.
            Phoenix and Spirit are both Proto-based domain-specific languages with
            their own distinct syntax and semantics. But you can freely embed Phoenix
            expressions within Spirit expressions. This section describes Proto's
            <span class="emphasis"><em>sub-domain</em></span> feature that lets you define families
            of interoperable domains.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.h0"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.dueling_domains"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.dueling_domains">Dueling
            Domains</a>
          </h6>
<p>
            When you try to create an expression from two sub-expressions in different
            domains, what is the domain of the resulting expression? This is the
            fundamental problem that is addressed by sub-domains. Consider the following
            code:
          </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">proto</span><span class="special">/</span><span class="identifier">proto</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">proto</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">proto</span><span class="special">;</span>

<span class="comment">// Forward-declare two expression wrappers</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">spirit_expr</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">phoenix_expr</span><span class="special">;</span>

<span class="comment">// Define two domains</span>
<span class="keyword">struct</span> <span class="identifier">spirit_domain</span>  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">spirit_expr</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">phoenix_domain</span> <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">phoenix_expr</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{};</span>

<span class="comment">// Implement the two expression wrappers</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">spirit_expr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">,</span> <span class="identifier">spirit_expr</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">&gt;,</span> <span class="identifier">spirit_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">spirit_expr</span><span class="special">(</span><span class="identifier">E</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">e</span> <span class="special">=</span> <span class="identifier">E</span><span class="special">())</span> <span class="special">:</span> <span class="identifier">spirit_expr</span><span class="special">::</span><span class="identifier">proto_extends</span><span class="special">(</span><span class="identifier">e</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">phoenix_expr</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">extends</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">,</span> <span class="identifier">phoenix_expr</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">&gt;,</span> <span class="identifier">phoenix_domain</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">phoenix_expr</span><span class="special">(</span><span class="identifier">E</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">e</span> <span class="special">=</span> <span class="identifier">E</span><span class="special">())</span> <span class="special">:</span> <span class="identifier">phoenix_expr</span><span class="special">::</span><span class="identifier">proto_extends</span><span class="special">(</span><span class="identifier">e</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">spirit_domain</span><span class="special">&gt;</span> <span class="identifier">sp</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">phoenix_domain</span><span class="special">&gt;</span> <span class="identifier">phx</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

    <span class="comment">// Whoops! What does it mean to add two expressions in different domains?</span>
    <span class="identifier">sp</span> <span class="special">+</span> <span class="identifier">phx</span><span class="special">;</span> <span class="comment">// ERROR</span>
<span class="special">}</span>
</pre>
<p>
            Above, we define two domains called <code class="computeroutput"><span class="identifier">spirit_domain</span></code>
            and <code class="computeroutput"><span class="identifier">phoenix_domain</span></code> and
            declare two int literals in each. Then we try to compose them into a
            larger expression using Proto's binary plus operator, and it fails. Proto
            can't figure out whether the resulting expression should be in the Spirit
            domain or the Phoenix domain, and thus whether it should be an instance
            of <code class="computeroutput"><span class="identifier">spirit_expr</span><span class="special">&lt;&gt;</span></code>
            or <code class="computeroutput"><span class="identifier">phoenix_expr</span><span class="special">&lt;&gt;</span></code>.
            We have to tell Proto how to resolve the conflict. We can do that by
            declaring that Phoenix is a sub-domain of Spirit as in the following
            definition of <code class="computeroutput"><span class="identifier">phoenix_domain</span></code>:
          </p>
<pre class="programlisting"><span class="comment">// Declare that phoenix_domain is a sub-domain of spirit_domain</span>
<span class="keyword">struct</span> <span class="identifier">phoenix_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">phoenix_expr</span><span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">,</span> <span class="bold"><strong>spirit_domain</strong></span><span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            The third template parameter to <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
            is the super-domain. By defining <code class="computeroutput"><span class="identifier">phoenix_domain</span></code>
            as above, we are saying that Phoenix expressions can be combined with
            Spirit expressions, and that when that happens, the resulting expression
            should be a Spirit expression.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              If you are wondering what the purpose of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code>
              is in the definition of <code class="computeroutput"><span class="identifier">phoenix_domain</span></code>
              above, recall that the second template parameter to <code class="computeroutput"><a class="link" href="../boost/proto/domain.html" title="Struct template domain">proto::domain&lt;&gt;</a></code>
              is the domain's grammar. <span class="quote">“<span class="quote"><code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span></code></span>”</span>
              is the default and signifies that the domain places no restrictions
              on the expressions that are valid within it.
            </p></td></tr>
</table></div>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.h1"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.domain_resolution"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.domain_resolution">Domain
            Resolution</a>
          </h6>
<p>
            When there are multiple domains in play within a given expression, Proto
            uses some rules to figure out which domain "wins". The rules
            are loosely modeled on the rules for C++ inheritance. <code class="computeroutput"><span class="identifier">Phoenix_domain</span></code>
            is a sub-domain of <code class="computeroutput"><span class="identifier">spirit_domain</span></code>.
            You can liken that to a derived/base relationship that gives Phoenix
            expressions a kind of implicit conversion to Spirit expressions. And
            since Phoenix expressions can be "converted" to Spirit expressions,
            they can be freely combined with Spirit expressions and the result is
            a Spirit expression.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              Super- and sub-domains are not actually implemented using inheritance.
              This is only a helpful mental model.
            </p></td></tr>
</table></div>
<p>
            The analogy with inheritance holds even in the case of three domains
            when two are sub-domains of the third. Imagine another domain called
            <code class="computeroutput"><span class="identifier">foobar_domain</span></code> that was
            also a sub-domain of <code class="computeroutput"><span class="identifier">spirit_domain</span></code>.
            Expressions in the <code class="computeroutput"><span class="identifier">foobar_domain</span></code>
            could be combined with expressions in the <code class="computeroutput"><span class="identifier">phoenix_domain</span></code>
            and the resulting expression would be in the <code class="computeroutput"><span class="identifier">spirit_domain</span></code>.
            That's because expressions in the two sub-domains both have "conversions"
            to the super-domain, so the operation is allowed and the super-domain
            wins.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.h2"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.the_default_domain"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.the_default_domain">The
            Default Domain</a>
          </h6>
<p>
            When you don't assign a Proto expression to a particular domain, Proto
            considers it a member of the so-called default domain, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span></code>. Even non-Proto objects
            are treated as terminals in the default domain. Consider:
          </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">spirit_domain</span><span class="special">&gt;</span> <span class="identifier">sp</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

    <span class="comment">// Add 1 to a spirit expression. Result is a spirit expression.</span>
    <span class="identifier">sp</span> <span class="special">+</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            Expressions in the default domain (or non-expressions like <code class="literal">1</code>)
            have a kind of implicit conversion to expressions every other domain
            type. What's more, you can define your domain to be a sub-domain of the
            default domain. In so doing, you give expressions in your domain conversions
            to expressions in every other domain. This is like a <span class="quote">“<span class="quote">free love</span>”</span>
            domain, because it will freely mix with all other domains.
          </p>
<p>
            Let's think again about the Phoenix EDSL. Since it provides generally
            useful lambda functionality, it's reasonable to assume that lots of other
            EDSLs besides Spirit might want the ability to embed Phoenix expressions.
            In other words, <code class="computeroutput"><span class="identifier">phoenix_domain</span></code>
            should be a sub-domain of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span></code>,
            not <code class="computeroutput"><span class="identifier">spirit_domain</span></code>:
          </p>
<pre class="programlisting"><span class="comment">// Declare that phoenix_domain is a sub-domain of proto::default_domain</span>
<span class="keyword">struct</span> <span class="identifier">phoenix_domain</span>
  <span class="special">:</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">domain</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">generator</span><span class="special">&lt;</span><span class="identifier">phoenix_expr</span><span class="special">&gt;,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">_</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span><span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
            That's much better. Phoenix expressions can now be put anywhere.
          </p>
<h6>
<a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.h3"></a>
            <span class="phrase"><a name="boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.sub_domain_summary"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.customizing_expressions_in_your_domain.subdomains.sub_domain_summary">Sub-Domain
            Summary</a>
          </h6>
<p>
            Use Proto sub-domains to make it possible to mix expressions from multiple
            domains. And when you want expressions in your domain to freely combine
            with <span class="emphasis"><em>all</em></span> expressions, make it a sub-domain of <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span></code>.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.define_operators"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.define_operators" title="Adapting Existing Types to Proto">Adapting
        Existing Types to Proto</a>
</h4></div></div></div>
<p>
          The preceding discussions of defining Proto front ends have all made a
          big assumption: that you have the luxury of defining everything from scratch.
          What happens if you have existing types, say a matrix type and a vector
          type, that you would like to treat as if they were Proto terminals? Proto
          usually trades only in its own expression types, but with <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_33_3.html" title="Macro BOOST_PROTO_DEFINE_OPERATORS">BOOST_PROTO_DEFINE_OPERATORS</a></code>()</code>,
          it can accomodate your custom terminal types, too.
        </p>
<p>
          Let's say, for instance, that you have the following types and that you
          can't modify then to make them <span class="quote">“<span class="quote">native</span>”</span> Proto terminal types.
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">math</span>
<span class="special">{</span>
    <span class="comment">// A matrix type ...</span>
    <span class="keyword">struct</span> <span class="identifier">matrix</span> <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">};</span>

    <span class="comment">// A vector type ...</span>
    <span class="keyword">struct</span> <span class="identifier">vector</span> <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
          You can non-intrusively make objects of these types Proto terminals by
          defining the proper operator overloads using <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_33_3.html" title="Macro BOOST_PROTO_DEFINE_OPERATORS">BOOST_PROTO_DEFINE_OPERATORS</a></code>()</code>.
          The basic procedure is as follows:
        </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
              Define a trait that returns true for your types and false for all others.
            </li>
<li class="listitem">
              Reopen the namespace of your types and use <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_33_3.html" title="Macro BOOST_PROTO_DEFINE_OPERATORS">BOOST_PROTO_DEFINE_OPERATORS</a></code>()</code>
              to define a set of operator overloads, passing the name of the trait
              as the first macro parameter, and the name of a Proto domain (e.g.,
              <code class="computeroutput"><a class="link" href="../boost/proto/default_domain.html" title="Struct default_domain">proto::default_domain</a></code>)
              as the second.
            </li>
</ol></div>
<p>
          The following code demonstrates how it works.
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">math</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_terminal</span>
      <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span>
    <span class="special">{};</span>

    <span class="comment">// OK, "matrix" is a custom terminal type</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_terminal</span><span class="special">&lt;</span><span class="identifier">matrix</span><span class="special">&gt;</span>
      <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
    <span class="special">{};</span>

    <span class="comment">// OK, "vector" is a custom terminal type</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_terminal</span><span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
      <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span>
    <span class="special">{};</span>

    <span class="comment">// Define all the operator overloads to construct Proto</span>
    <span class="comment">// expression templates, treating "matrix" and "vector"</span>
    <span class="comment">// objects as if they were Proto terminals.</span>
    <span class="identifier">BOOST_PROTO_DEFINE_OPERATORS</span><span class="special">(</span><span class="identifier">is_terminal</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">default_domain</span><span class="special">)</span>
<span class="special">}</span>
</pre>
<p>
          The invocation of the <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_33_3.html" title="Macro BOOST_PROTO_DEFINE_OPERATORS">BOOST_PROTO_DEFINE_OPERATORS</a></code>()</code>
          macro defines a complete set of operator overloads that treat <code class="computeroutput"><span class="identifier">matrix</span></code> and <code class="computeroutput"><span class="identifier">vector</span></code>
          objects as if they were Proto terminals. And since the operators are defined
          in the same namespace as the <code class="computeroutput"><span class="identifier">matrix</span></code>
          and <code class="computeroutput"><span class="identifier">vector</span></code> types, the operators
          will be found by argument-dependent lookup. With the code above, we can
          now construct expression templates with matrices and vectors, as shown
          below.
        </p>
<pre class="programlisting"><span class="identifier">math</span><span class="special">::</span><span class="identifier">matrix</span> <span class="identifier">m1</span><span class="special">;</span>
<span class="identifier">math</span><span class="special">::</span><span class="identifier">vector</span> <span class="identifier">v1</span><span class="special">;</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">literal</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">i</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

<span class="identifier">m1</span> <span class="special">*</span> <span class="number">1</span><span class="special">;</span>  <span class="comment">// custom terminal and literals are OK</span>
<span class="identifier">m1</span> <span class="special">*</span> <span class="identifier">i</span><span class="special">;</span>  <span class="comment">// custom terminal and Proto expressions are OK</span>
<span class="identifier">m1</span> <span class="special">*</span> <span class="identifier">v1</span><span class="special">;</span> <span class="comment">// two custom terminals are OK, too.</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.front_end.code_repetition"></a><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.code_repetition" title="Generating Repetitive Code with the Preprocessor">Generating
        Repetitive Code with the Preprocessor</a>
</h4></div></div></div>
<p>
          Sometimes as an EDSL designer, to make the lives of your users easy, you
          have to make your own life hard. Giving your users natural and flexible
          syntax often involves writing large numbers of repetitive function overloads.
          It can be enough to give you repetitive stress injury! Before you hurt
          yourself, check out the macros Proto provides for automating many repetitive
          code-generation chores.
        </p>
<p>
          Imagine that we are writing a lambda EDSL, and we would like to enable
          syntax for constructing temporary objects of any type using the following
          syntax:
        </p>
<pre class="programlisting"><span class="comment">// A lambda expression that takes two arguments and</span>
<span class="comment">// uses them to construct a temporary std::complex&lt;&gt;</span>
<span class="identifier">construct</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;(</span> <span class="identifier">_1</span><span class="special">,</span> <span class="identifier">_2</span> <span class="special">)</span>
</pre>
<p>
          For the sake of the discussion, imagine that we already have a function
          object template <code class="computeroutput"><span class="identifier">construct_impl</span><span class="special">&lt;&gt;</span></code> that accepts arguments and constructs
          new objects from them. We would want the above lambda expression to be
          equivalent to the following:
        </p>
<pre class="programlisting"><span class="comment">// The above lambda expression should be roughly equivalent</span>
<span class="comment">// to the following:</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">&gt;(</span>
    <span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;()</span> <span class="comment">// The function to invoke lazily</span>
  <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">_1</span><span class="special">)</span>                       <span class="comment">// The first argument to the function</span>
  <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">_2</span><span class="special">)</span>                       <span class="comment">// The second argument to the function</span>
<span class="special">);</span>
</pre>
<p>
          We can define our <code class="computeroutput"><span class="identifier">construct</span><span class="special">()</span></code> function template as follows:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A1</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span>
  <span class="special">,</span> <span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
  <span class="special">,</span> <span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span>
  <span class="special">,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span>
<span class="identifier">construct</span><span class="special">(</span><span class="identifier">A0</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a0</span><span class="special">,</span> <span class="identifier">A1</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">a1</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">&gt;(</span>
        <span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span>
      <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a0</span><span class="special">)</span>
      <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a1</span><span class="special">)</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          This works for two arguments, but we would like it to work for any number
          of arguments, up to ( <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_MAX_ARITY.html" title="Macro BOOST_PROTO_MAX_ARITY">BOOST_PROTO_MAX_ARITY</a></code></code>
          - 1). (Why "- 1"? Because one child is taken up by the <code class="computeroutput"><span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span></code>
          terminal leaving room for only ( <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_MAX_ARITY.html" title="Macro BOOST_PROTO_MAX_ARITY">BOOST_PROTO_MAX_ARITY</a></code></code>
          - 1) other children.)
        </p>
<p>
          For cases like this, Proto provides the <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT.html" title="Macro BOOST_PROTO_REPEAT">BOOST_PROTO_REPEAT</a></code>()</code>
          and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT_FROM_TO.html" title="Macro BOOST_PROTO_REPEAT_FROM_TO">BOOST_PROTO_REPEAT_FROM_TO</a></code>()</code>
          macros. To use it, we turn the function definition above into a macro as
          follows:
        </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">M0</span><span class="special">(</span><span class="identifier">N</span><span class="special">,</span> <span class="identifier">typename_A</span><span class="special">,</span> <span class="identifier">A_const_ref</span><span class="special">,</span> <span class="identifier">A_const_ref_a</span><span class="special">,</span> <span class="identifier">ref_a</span><span class="special">)</span>  <span class="special">\</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="identifier">typename_A</span><span class="special">(</span><span class="identifier">N</span><span class="special">)&gt;</span>                           <span class="special">\</span>
<span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span>                         <span class="special">\</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span>                                      <span class="special">\</span>
  <span class="special">,</span> <span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>                                         <span class="special">\</span>
  <span class="special">,</span> <span class="identifier">A_const_ref</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span>                                            <span class="special">\</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span>                                                 <span class="special">\</span>
<span class="identifier">construct</span><span class="special">(</span><span class="identifier">A_const_ref_a</span><span class="special">(</span><span class="identifier">N</span><span class="special">))</span>                                   <span class="special">\</span>
<span class="special">{</span>                                                             <span class="special">\</span>
    <span class="keyword">return</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">make_expr</span><span class="special">&lt;</span><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">function</span><span class="special">&gt;(</span>            <span class="special">\</span>
        <span class="identifier">construct_impl</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span>                                   <span class="special">\</span>
      <span class="special">,</span> <span class="identifier">ref_a</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span>                                              <span class="special">\</span>
    <span class="special">);</span>                                                        <span class="special">\</span>
<span class="special">}</span>
</pre>
<p>
          Notice that we turned the function into a macro that takes 5 arguments.
          The first is the current iteration number. The rest are the names of other
          macros that generate different sequences. For instance, Proto passes as
          the second parameter the name of a macro that will expand to <code class="computeroutput"><span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A1</span><span class="special">,</span> <span class="special">...</span></code>.
        </p>
<p>
          Now that we have turned our function into a macro, we can pass the macro
          to <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT_FROM_TO.html" title="Macro BOOST_PROTO_REPEAT_FROM_TO">BOOST_PROTO_REPEAT_FROM_TO</a></code>()</code>.
          Proto will invoke it iteratively, generating all the function overloads
          for us.
        </p>
<pre class="programlisting"><span class="comment">// Generate overloads of construct() that accept from</span>
<span class="comment">// 1 to BOOST_PROTO_MAX_ARITY-1 arguments:</span>
<span class="identifier">BOOST_PROTO_REPEAT_FROM_TO</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">BOOST_PROTO_MAX_ARITY</span><span class="special">,</span> <span class="identifier">M0</span><span class="special">)</span>
<span class="preprocessor">#undef</span> <span class="identifier">M0</span>
</pre>
<h6>
<a name="boost_proto.users_guide.front_end.code_repetition.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.front_end.code_repetition.non_default_sequences"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.front_end.code_repetition.non_default_sequences">Non-Default
          Sequences</a>
        </h6>
<p>
          As mentioned above, Proto passes as the last 4 arguments to your macro
          the names of other macros that generate various sequences. The macros
          <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT.html" title="Macro BOOST_PROTO_REPEAT">BOOST_PROTO_REPEAT</a></code>()</code>
          and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT_FROM_TO.html" title="Macro BOOST_PROTO_REPEAT_FROM_TO">BOOST_PROTO_REPEAT_FROM_TO</a></code>()</code>
          select defaults for these parameters. If the defaults do not meet your
          needs, you can use <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT_EX.html" title="Macro BOOST_PROTO_REPEAT_EX">BOOST_PROTO_REPEAT_EX</a></code>()</code>
          and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_37_5.html" title="Macro BOOST_PROTO_REPEAT_FROM_TO_EX">BOOST_PROTO_REPEAT_FROM_TO_EX</a></code>()</code>
          and pass different macros that generate different sequences. Proto defines
          a number of such macros for use as parameters to <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT_EX.html" title="Macro BOOST_PROTO_REPEAT_EX">BOOST_PROTO_REPEAT_EX</a></code>()</code>
          and <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO__1_3_32_5_37_5.html" title="Macro BOOST_PROTO_REPEAT_FROM_TO_EX">BOOST_PROTO_REPEAT_FROM_TO_EX</a></code>()</code>.
          Check the reference section for <code class="computeroutput"><a class="link" href="reference.html#header.boost.proto.repeat_hpp" title="Header &lt;boost/proto/repeat.hpp&gt;">boost/proto/repeat.hpp</a></code>
          for all the details.
        </p>
<p>
          Also, check out <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_LOCAL_ITERATE.html" title="Macro BOOST_PROTO_LOCAL_ITERATE">BOOST_PROTO_LOCAL_ITERATE</a></code>()</code>.
          It works similarly to <code class="literal"><code class="computeroutput"><a class="link" href="../BOOST_PROTO_REPEAT.html" title="Macro BOOST_PROTO_REPEAT">BOOST_PROTO_REPEAT</a></code>()</code>
          and friends, but it can be easier to use when you want to change one macro
          argument and accept defaults for the others.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_proto.users_guide.intermediate_form"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form" title="Intermediate Form: Understanding and Introspecting Expressions">Intermediate
      Form: Understanding and Introspecting Expressions</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child">Accessing
        Parts of an Expression</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.deep_copying_expressions">Deep-copying
        Expressions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.debugging_expressions">Debugging
        Expressions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.tags_and_metafunctions">Operator
        Tags and Metafunctions</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expressions_as_fusion_sequences">Expressions
        as Fusion Sequences</a></span></dt>
<dt><span class="section"><a href="users_guide.html#boost_proto.users_guide.intermediate_form.expression_introspection">Expression
        Introspection: Defining a Grammar</a></span></dt>
</dl></div>
<p>
        By now, you know a bit about how to build a front-end for your EDSL "compiler"
        -- you can define terminals and functions that generate expression templates.
        But we haven't said anything about the expression templates themselves. What
        do they look like? What can you do with them? In this section we'll see.
      </p>
<h5>
<a name="boost_proto.users_guide.intermediate_form.h0"></a>
        <span class="phrase"><a name="boost_proto.users_guide.intermediate_form.the__literal_expr_lt__gt___literal__type"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.the__literal_expr_lt__gt___literal__type">The
        <code class="literal">expr&lt;&gt;</code> Type</a>
      </h5>
<p>
        All Proto expressions are an instantiation of a template called <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> (or a wrapper around
        such an instantiation). When we define a terminal as below, we are really
        initializing an instance of the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        template.
      </p>
<pre class="programlisting"><span class="comment">// Define a placeholder type</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="identifier">I</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">placeholder</span>
<span class="special">{};</span>

<span class="comment">// Define the Protofied placeholder terminal</span>
<span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="keyword">const</span> <span class="identifier">_1</span> <span class="special">=</span> <span class="special">{{}};</span>
</pre>
<p>
        The actual type of <code class="computeroutput"><span class="identifier">_1</span></code> looks
        like this:
      </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;,</span> <span class="number">0</span> <span class="special">&gt;</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> template is the most
        important type in Proto. Although you will rarely need to deal with it directly,
        it's always there behind the scenes holding your expression trees together.
        In fact, <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> <span class="emphasis"><em>is</em></span>
        the expression tree -- branches, leaves and all.
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> template makes up the
        nodes in expression trees. The first template parameter is the node type;
        in this case, <code class="computeroutput"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span></code>.
        That means that <code class="computeroutput"><span class="identifier">_1</span></code> is a leaf-node
        in the expression tree. The second template parameter is a list of child
        types, or in the case of terminals, the terminal's value type. Terminals
        will always have only one type in the type list. The last parameter is the
        arity of the expression. Terminals have arity 0, unary expressions have arity
        1, etc.
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> struct is defined as
        follows:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">,</span> <span class="keyword">long</span> <span class="identifier">Arity</span> <span class="special">=</span> <span class="identifier">Args</span><span class="special">::</span><span class="identifier">arity</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">expr</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">expr</span><span class="special">&lt;</span> <span class="identifier">Tag</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">,</span> <span class="number">1</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Args</span><span class="special">::</span><span class="identifier">child0</span> <span class="identifier">proto_child0</span><span class="special">;</span>
    <span class="identifier">proto_child0</span> <span class="identifier">child0</span><span class="special">;</span>
    <span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> struct does not define
        a constructor, or anything else that would prevent static initialization.
        All <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code> objects are initialized
        using <span class="emphasis"><em>aggregate initialization</em></span>, with curly braces. In
        our example, <code class="computeroutput"><span class="identifier">_1</span></code> is initialized
        with the initializer <code class="computeroutput"><span class="special">{{}}</span></code>. The
        outer braces are the initializer for the <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>
        struct, and the inner braces are for the member <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>
        which is of type <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code>.
        Note that we use braces to initialize <code class="computeroutput"><span class="identifier">_1</span><span class="special">.</span><span class="identifier">child0</span></code>
        because <code class="computeroutput"><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></code> is also
        an aggregate.
      </p>
<h5>
<a name="boost_proto.users_guide.intermediate_form.h1"></a>
        <span class="phrase"><a name="boost_proto.users_guide.intermediate_form.building_expression_trees"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.building_expression_trees">Building
        Expression Trees</a>
      </h5>
<p>
        The <code class="computeroutput"><span class="identifier">_1</span></code> node is an instantiation
        of <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>, and expressions containing
        <code class="computeroutput"><span class="identifier">_1</span></code> are also instantiations
        of <code class="computeroutput"><a class="link" href="../boost/proto/expr.html" title="Struct template expr">proto::expr&lt;&gt;</a></code>. To use Proto effectively,
        you won't have to bother yourself with the actual types that Proto generates.
        These are details, but you're likely to encounter these types in compiler
        error messages, so it's helpful to be familiar with them. The types look
        like this:
      </p>
<pre class="programlisting"><span class="comment">// The type of the expression -_1</span>
<span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">negate</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">list1</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="number">1</span>
    <span class="special">&gt;</span>
<span class="identifier">negate_placeholder_type</span><span class="special">;</span>

<span class="identifier">negate_placeholder_type</span> <span class="identifier">x</span> <span class="special">=</span> <span class="special">-</span><span class="identifier">_1</span><span class="special">;</span>

<span class="comment">// The type of the expression _1 + 42</span>
<span class="keyword">typedef</span>
    <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
        <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span>
      <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">list2</span><span class="special">&lt;</span>
            <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="identifier">placeholder</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">expr</span><span class="special">&lt;</span>
                <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">terminal</span>
              <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">term</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="special">&gt;</span>
              <span class="special">,</span> <span class="number">0</span>
            <span class="special">&gt;</span>
        <span class="special">&gt;</span>
      <span class="special">,</span> <span class="number">2</span>
    <span class="special">&gt;</span>
<span class="identifier">placeholder_plus_int_type</span><span class="special">;</span>

<span class="identifier">placeholder_plus_int_type</span> <span class="identifier">y</span> <span class="special">=</span> <span class="identifier">_1</span> <span class="special">+</span> <span class="number">42</span><span class="special">;</span>
</pre>
<p>
        There are a few things to note about these types:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Terminals have arity zero, unary expressions have arity one and binary
            expressions have arity two.
          </li>
<li class="listitem">
            When one Proto expression is made a child node of another Proto expression,
            it is held by reference, <span class="emphasis"><em>even if it is a temporary object</em></span>.
            This last point becomes important later.
          </li>
<li class="listitem">
            Non-Proto expressions, such as the integer literal, are turned into Proto
            expressions by wrapping them in new <code class="computeroutput"><span class="identifier">expr</span><span class="special">&lt;&gt;</span></code> terminal objects. These new wrappers
            are not themselves held by reference, but the object wrapped <span class="emphasis"><em>is</em></span>.
            Notice that the type of the Protofied <code class="computeroutput"><span class="number">42</span></code>
            literal is <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
            <span class="special">&amp;</span></code> -- held by reference.
          </li>
</ul></div>
<p>
        The types make it clear: everything in a Proto expression tree is held by
        reference. That means that building an expression tree is exceptionally cheap.
        It involves no copying at all.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          An astute reader will notice that the object <code class="computeroutput"><span class="identifier">y</span></code>
          defined above will be left holding a dangling reference to a temporary
          int. In the sorts of high-performance applications Proto addresses, it
          is typical to build and evaluate an expression tree before any temporary
          objects go out of scope, so this dangling reference situation often doesn't
          arise, but it is certainly something to be aware of. Proto provides utilities
          for deep-copying expression trees so they can be passed around as value
          types without concern for dangling references.
        </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_proto.users_guide.intermediate_form.left_right_child"></a><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child" title="Accessing Parts of an Expression">Accessing
        Parts of an Expression</a>
</h4></div></div></div>
<p>
          After assembling an expression into a tree, you'll naturally want to be
          able to do the reverse, and access a node's children. You may even want
          to be able to iterate over the children with algorithms from the Boost.Fusion
          library. This section shows how.
        </p>
<h6>
<a name="boost_proto.users_guide.intermediate_form.left_right_child.h0"></a>
          <span class="phrase"><a name="boost_proto.users_guide.intermediate_form.left_right_child.getting_expression_tags_and_arities"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child.getting_expression_tags_and_arities">Getting
          Expression Tags and Arities</a>
        </h6>
<p>
          Every node in an expression tree has both a <span class="emphasis"><em>tag</em></span> type
          that describes the node, and an <span class="emphasis"><em>arity</em></span> corresponding
          to the number of child nodes it has. You can use the <code class="computeroutput"><a class="link" href="../boost/proto/tag_of.html" title="Struct template tag_of">proto::tag_of&lt;&gt;</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/proto/arity_of.html" title="Struct template arity_of">proto::arity_of&lt;&gt;</a></code> metafunctions to fetch
          them. Consider the following:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">check_plus_node</span><span class="special">(</span><span class="identifier">Expr</span> <span class="keyword">const</span> <span class="special">&amp;)</span>
<span class="special">{</span>
    <span class="comment">// Assert that the tag type is proto::tag::plus</span>
    <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span>
            <span class="keyword">typename</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">type</span>
          <span class="special">,</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">tag</span><span class="special">::</span><span class="identifier">plus</span>
        <span class="special">&gt;::</span><span class="identifier">value</span>
    <span class="special">));</span>

    <span class="comment">// Assert that the arity is 2</span>
    <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">arity_of</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="number">2</span> <span class="special">);</span>
<span class="special">}</span>

<span class="comment">// Create a binary plus node and use check_plus_node()</span>
<span class="comment">// to verify its tag type and arity:</span>
<span class="identifier">check_plus_node</span><span class="special">(</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">lit</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="number">2</span> <span class="special">);</span>
</pre>
<p>
          For a given type <code class="computeroutput"><span class="identifier">Expr</span></code>,
          you could access the tag and arity directly as <code class="computeroutput"><span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_tag</span></code>
          and <code class="computeroutput"><span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_arity</span></code>, where <code class="computeroutput"><span class="identifier">Expr</span><span class="special">::</span><span class="identifier">proto_arity</span></code>
          is an MPL Integral Constant.
        </p>
<h6>
<a name="boost_proto.users_guide.intermediate_form.left_right_child.h1"></a>
          <span class="phrase"><a name="boost_proto.users_guide.intermediate_form.left_right_child.getting_terminal_values"></a></span><a class="link" href="users_guide.html#boost_proto.users_guide.intermediate_form.left_right_child.getting_terminal_values">Getting
          Terminal Values</a>
        </h6>
<p>
          There is no simpler expression than a terminal, and no more basic operation
          than extracting its value. As we've already seen, that is what <code class="computeroutput"><a class="link" href="../boost/proto/value.html" title="Function value">proto::value()</a></code> is for.
        </p>
<pre class="programlisting"><span class="identifier">proto</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">cout_</span> <span class="special">=</span> <span class="special">{</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">};</span>

<span class="comment">// Get the value of the cout_ terminal:</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span> <span class="special">&amp;</span> <span class="identifier">sout</span> <span class="special">=</span> <span class="identifier">proto</span><span class="special">::</span><span class="identifier">value</span><span class="special">(</span> <span class="identifier">cout_</span> <span class="special">);</span>

<span class="comment">// Assert that we got back what we put in:</span>
<span class="identifier">assert</span><span class="special">(</span> <span class="special">&amp;</span><span class="identifier">sout</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">);</span>
</pre>
<p>
          To compute the return type of the <code class="computeroutput"><a class="link" href="../boost/proto/value.html" title="Function value">proto::value()</a></code>
          function, you can use <code class="computeroutput"><a class="link" href="../boost/proto/result_of/value.html" title="Struct template value">proto::result_of::value&lt;&gt;</a></code>.
          When the parameter to <code class="computeroutput"><a class="link" href="../boost/proto/result_of/value.html" title="Struct template value">proto::result_of::value&lt;&gt;</a></code>
          is a non-reference type, the result type of the metafunction is the type
          of the value as suitable for storage by value; that is, top-level reference
          and qualifiers are stripped from it. But when instantiated with a reference
          type, the result type has a reference <span class="emphasis"><em>added</em></span> to it,
          yielding a type suitable for storage by reference. If you want to know
          the actual type of the terminal's value including whether it is stored
          by value or reference, you can use <code class="computeroutput"><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">::</span><span class="identifier">value_at</span><span class="special">&lt;</span><span class="identifier">Expr</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;::</span><span class="identifier">type</span></code>.
        </p>
<p>
          The following table summarizes the above paragraph.
        </p>
<div class="table">
<a name="boost_proto.users_guide.intermediate_form.left_right_child.t0"></a><p class="title"><b>Table 31.4. Accessing Value Types</b></p>
<div class="table-contents"><table class="table" summary="Accessing Value Types">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Metafunction Invocati