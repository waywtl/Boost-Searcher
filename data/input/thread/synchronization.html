<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Synchronization</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../thread.html" title="Chapter 38. Thread 4.8.0">
<link rel="prev" href="ScopedThreads.html" title="Scoped Threads">
<link rel="next" href="thread_local_storage.html" title="Thread Local Storage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="ScopedThreads.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="thread.synchronization"></a><a class="link" href="synchronization.html" title="Synchronization">Synchronization</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial">Tutorial</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts">Mutex Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_option">Lock Options</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard">Lock Guard</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.with_lock_guard">With Lock Guard</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts">Lock Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks">Lock Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks">Other Lock Types
      - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions">Lock functions</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_factories">Lock Factories
      - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types">Mutex Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref">Condition Variables</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once">One-time Initialization</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers">Barriers -- EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.latches">Latches -- EXPERIMENTAL</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.executors">Executors and Schedulers
      -- EXPERIMENTAL</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures">Futures</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.tutorial"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial" title="Tutorial">Tutorial</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking">Internal
        Locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.with">Executing Around
        a Function</a></span></dt>
</dl></div>
<p>
        <a href="http://web.archive.org/web/20140531071228/http://home.roadrunner.com/~hinnant/mutexes/locking.html" target="_top">Handling
        mutexes in C++</a> is an excellent tutorial. You need just replace std
        and ting by boost.
      </p>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html" target="_top">Mutex,
        Lock, Condition Variable Rationale</a> adds rationale for the design
        decisions made for mutexes, locks and condition variables.
      </p>
<p>
        In addition to the C++11 standard locks, Boost.Thread provides other locks
        and some utilities that help the user to make their code thread-safe.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.internal_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking" title="Internal Locking">Internal
        Locking</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_locking">Internal
          locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking">Internal
          and external locking</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of chapter Concurrency of the Object-Oriented
            Programming in the BETA Programming Language and of the paper of Andrei
            Alexandrescu "Multithreading and the C++ Type System" to the
            Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution" title="Concurrent threads of execution">Concurrent
          threads of execution</a>
</h5></div></div></div>
<p>
            Consider, for example, modeling a bank account class that supports simultaneous
            deposits and withdrawals from multiple locations (arguably the "Hello,
            World" of multithreaded programming).
          </p>
<p>
            From here a component is a model of the <code class="computeroutput"><span class="identifier">Callable</span></code>
            concept.
          </p>
<p>
            I C++11 (Boost) concurrent execution of a component is obtained by means
            of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span></code>(<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code>):
          </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">S</span><span class="special">);</span>
</pre>
<p>
            where <code class="computeroutput"><span class="identifier">S</span></code> is a model of
            <code class="computeroutput"><span class="identifier">Callable</span></code>. The meaning
            of this expression is that execution of <code class="computeroutput"><span class="identifier">S</span><span class="special">()</span></code> will take place concurrently with the
            current thread of execution executing the expression.
          </p>
<p>
            The following example includes a bank account of a person (Joe) and two
            components, one corresponding to a bank agent depositing money in Joe's
            account, and one representing Joe. Joe will only be withdrawing money
            from the account:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span><span class="special">;</span>

<span class="identifier">BankAccount</span> <span class="identifier">JoesAccount</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">bankAgent</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Deposit</span><span class="special">(</span><span class="number">500</span><span class="special">);</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">Joe</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="keyword">int</span> <span class="identifier">myPocket</span> <span class="special">=</span> <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">100</span><span class="special">);</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">myPocket</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//...</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">bankAgent</span><span class="special">);</span> <span class="comment">// start concurrent execution of bankAgent</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread2</span><span class="special">(</span><span class="identifier">Joe</span><span class="special">);</span> <span class="comment">// start concurrent execution of Joe</span>
    <span class="identifier">thread1</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="identifier">thread2</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            From time to time, the <code class="computeroutput"><span class="identifier">bankAgent</span></code>
            will deposit $500 in <code class="computeroutput"><span class="identifier">JoesAccount</span></code>.
            <code class="computeroutput"><span class="identifier">Joe</span></code> will similarly withdraw
            $100 from his account. These sentences describe that the <code class="computeroutput"><span class="identifier">bankAgent</span></code> and <code class="computeroutput"><span class="identifier">Joe</span></code>
            are executed concurrently.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_locking" title="Internal locking">Internal
          locking</a>
</h5></div></div></div>
<p>
            The above example works well as long as the components <code class="computeroutput"><span class="identifier">bankAgent</span></code> and <code class="computeroutput"><span class="identifier">Joe</span></code>
            doesn't access <code class="computeroutput"><span class="identifier">JoesAccount</span></code>
            at the same time. There is, however, no guarantee that this will not
            happen. We may use a mutex to guarantee exclusive access to each bank.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="keyword">int</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">balance_</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">b</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Execution of the <code class="computeroutput"><span class="identifier">Deposit</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span></code> operations
            will no longer be able to make simultaneous access to balance.
          </p>
<p>
            A mutex is a simple and basic mechanism for obtaining synchronization.
            In the above example it is relatively easy to be convinced that the synchronization
            works correctly (in the absence of exception). In a system with several
            concurrent objects and several shared objects, it may be difficult to
            describe synchronization by means of mutexes. Programs that make heavy
            use of mutexes may be difficult to read and write. Instead, we shall
            introduce a number of generic classes for handling more complicated forms
            of synchronization and communication.
          </p>
<p>
            With the RAII idiom we can simplify a lot this using the scoped locks.
            In the code below, guard's constructor locks the passed-in object <code class="computeroutput"><span class="identifier">mtx_</span></code>, and guard's destructor unlocks
            <code class="computeroutput"><span class="identifier">mtx_</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="comment">// explicit mutex declaration </span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The object-level locking idiom doesn't cover the entire richness of a
            threading model. For example, the model above is quite deadlock-prone
            when you try to coordinate multi-object transactions. Nonetheless, object-level
            locking is useful in many cases, and in combination with other mechanisms
            can provide a satisfactory solution to many threaded access problems
            in object-oriented programs.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_and_external_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking" title="Internal and external locking">Internal
          and external locking</a>
</h5></div></div></div>
<p>
            The BankAccount class above uses internal locking. Basically, a class
            that uses internal locking guarantees that any concurrent calls to its
            public member functions don't corrupt an instance of that class. This
            is typically ensured by having each public member function acquire a
            lock on the object upon entry. This way, for any given object of that
            class, there can be only one member function call active at any moment,
            so the operations are nicely serialized.
          </p>
<p>
            This approach is reasonably easy to implement and has an attractive simplicity.
            Unfortunately, "simple" might sometimes morph into "simplistic."
          </p>
<p>
            Internal locking is insufficient for many real-world synchronization
            tasks. Imagine that you want to implement an ATM withdrawal transaction
            with the BankAccount class. The requirements are simple. The ATM transaction
            consists of two withdrawals-one for the actual money and one for the
            $2 commission. The two withdrawals must appear in strict sequence; that
            is, no other transaction can exist between them.
          </p>
<p>
            The obvious implementation is erratic:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="comment">// preemption possible</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The problem is that between the two calls above, another thread can perform
            another operation on the account, thus breaking the second design requirement.
          </p>
<p>
            In an attempt to solve this problem, let's lock the account from the
            outside during the two operations:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">.</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="number">1</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that the code above doesn't compile, the <code class="computeroutput"><span class="identifier">mtx_</span></code>
            field is private. We have two possibilities:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                make <code class="computeroutput"><span class="identifier">mtx_</span></code> public
                which seems odd
              </li>
<li class="listitem">
                make the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                lockable by adding the lock/unlock functions
              </li>
</ul></div>
<p>
            We can add these functions explicitly
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            or inheriting from a class which add these lockable functions.
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">basic_lockable_adapter</span></code>
            class helps to define the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            class as
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            and the code that doesn't compiles becomes
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that now acct is being locked by Withdraw after it has already
            been locked by guard. When running such code, one of two things happens.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Your mutex implementation might support the so-called recursive mutex
                semantics. This means that the same thread can lock the same mutex
                several times successfully. In this case, the implementation works
                but has a performance overhead due to unnecessary locking. (The locking/unlocking
                sequence in the two Withdraw calls is not needed but performed anyway-and
                that costs time.)
              </li>
<li class="listitem">
                Your mutex implementation might not support recursive locking, which
                means that as soon as you try to acquire it the second time, it blocks-so
                the ATMWithdrawal function enters the dreaded deadlock.
              </li>
</ul></div>
<p>
            As <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code> is not recursive, we need to
            use its recursive version <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>

    <span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The caller-ensured locking approach is more flexible and the most efficient,
            but very dangerous. In an implementation using caller-ensured locking,
            BankAccount still holds a mutex, but its member functions don't manipulate
            it at all. Deposit and Withdraw are not thread-safe anymore. Instead,
            the client code is responsible for locking BankAccount properly.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Obviously, the caller-ensured locking approach has a safety problem.
            BankAccount's implementation code is finite, and easy to reach and maintain,
            but there's an unbounded amount of client code that manipulates BankAccount
            objects. In designing applications, it's important to differentiate between
            requirements imposed on bounded code and unbounded code. If your class
            makes undue requirements on unbounded code, that's usually a sign that
            encapsulation is out the window.
          </p>
<p>
            To conclude, if in designing a multi-threaded class you settle on internal
            locking, you expose yourself to inefficiency or deadlocks. On the other
            hand, if you rely on caller-provided locking, you make your class error-prone
            and difficult to use. Finally, external locking completely avoids the
            issue by leaving it all to the client code.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes" title="External Locking -- strict_lock and externally_locked classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits">Locks
          as permits</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks">Allowing
          other strict locks</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of the paper by Andrei Alexandrescu "Multithreading
            and the C++ Type System" to the Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits" title="Locks as permits">Locks
          as permits</a>
</h5></div></div></div>
<p>
            So what to do? Ideally, the BankAccount class should do the following:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Support both locking models (internal and external).
              </li>
<li class="listitem">
                Be efficient; that is, use no unnecessary locking.
              </li>
<li class="listitem">
                Be safe; that is, BankAccount objects cannot be manipulated without
                appropriate locking.
              </li>
</ul></div>
<p>
            Let's make a worthwhile observation: Whenever you lock a BankAccount,
            you do so by using a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object. Turning this statement around,
            wherever there's a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>, there's also a locked <code class="computeroutput"><span class="identifier">BankAccount</span></code> somewhere. Thus, you can
            think of-and use-a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object as a permit. Owning a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            gives you rights to do certain things. The <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object should not be copied or aliased
            (it's not a transmissible permit).
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                As long as a permit is still alive, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                object stays locked.
              </li>
<li class="listitem">
                When the <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> is destroyed, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>'s mutex is released.
              </li>
</ol></div>
<p>
            The net effect is that at any point in your code, having access to a
            <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object guarantees that a <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked. (You don't know exactly which <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked, however-an issue that we'll address soon.)
          </p>
<p>
            For now, let's make a couple of enhancements to the <code class="computeroutput"><span class="identifier">lock_guard</span></code>
            class template defined in Boost.Thread. We'll call the enhanced version
            <code class="computeroutput"><span class="identifier">strict_lock</span></code>. Essentially,
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code>'s role
            is only to live on the stack as an automatic variable. <code class="computeroutput"><span class="identifier">strict_lock</span></code> must adhere to a non-copy
            and non-alias policy. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            disables copying by making the copy constructor and the assignment operator
            private.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_lock</span>  <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>


    <span class="keyword">explicit</span> <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// locks on construction</span>
    <span class="special">}</span>
    <span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">obj_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span> <span class="special">}</span> <span class="comment">//  unlocks on destruction </span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="comment">// strict lockers specific function </span>
    <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">l</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Silence can be sometimes louder than words-what's forbidden to do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> is as important
            as what you can do. Let's see what you can and what you cannot do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> instantiation:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                You can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> only starting from a valid T
                object. Notice that there is no other way you can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
              </li></ul></div>
<pre class="programlisting"><span class="identifier">BankAccount</span> <span class="identifier">myAccount</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
<span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">myLock</span><span class="special">(</span><span class="identifier">myAccount</span><span class="special">);</span> <span class="comment">// ok</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                You cannot copy <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                to one another. In particular, you cannot pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by value to functions or have them returned by functions:
              </li></ul></div>
<pre class="programlisting"><span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">Foo</span><span class="special">();</span> <span class="comment">// compile-time error</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;);</span> <span class="comment">// compile-time error</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                However, you still can pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by reference to and from functions:
              </li></ul></div>
<pre class="programlisting"><span class="comment">// ok, Foo returns a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">Foo</span><span class="special">();</span>
<span class="comment">// ok, Bar takes a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;);</span>
</pre>
<p>
            All these rules were put in place with one purpose-enforcing that owning
            a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            is a reasonably strong guarantee that
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                you locked a T object, and
              </li>
<li class="listitem">
                that object will be unlocked at a later point.
              </li>
</ol></div>
<p>
            Now that we have such a strict <code class="computeroutput"><span class="identifier">strict_lock</span></code>,
            how do we harness its power in defining a safe, flexible interface for
            BankAccount? The idea is as follows:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Each of BankAccount's interface functions (in our case, Deposit and
                Withdraw) comes in two overloaded variants.
              </li>
<li class="listitem">
                One version keeps the same signature as before, and the other takes
                an additional argument of type <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>. The first version is internally
                locked; the second one requires external locking. External locking
                is enforced at compile time by requiring client code to create a
                <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
                object.
              </li>
<li class="listitem">
                BankAccount avoids code bloating by having the internal locked functions
                forward to the external locked functions, which do the actual job.
              </li>
</ul></div>
<p>
            A little code is worth 1,000 words, a (hacked into) saying goes, so here's
            the new BankAccount class:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now, if you want the benefit of internal locking, you simply call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span></code> and
            <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span></code>.
            If you want to use external locking, you lock the object by constructing
            a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            and then you call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            For example, here's the <code class="computeroutput"><span class="identifier">ATMWithdrawal</span></code>
            function implemented correctly:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This function has the best of both worlds-it's reasonably safe and efficient
            at the same time.
          </p>
<p>
            It's worth noting that <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            being a template gives extra safety compared to a straight polymorphic
            approach. In such a design, BankAccount would derive from a Lockable
            interface. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            would manipulate Lockable references so there's no need for templates.
            This approach is sound; however, it provides fewer compile-time guarantees.
            Having a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            object would only tell that some object derived from Lockable is currently
            locked. In the templated approach, having a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> gives a stronger guarantee-it's a
            <code class="computeroutput"><span class="identifier">BankAccount</span></code> that stays
            locked.
          </p>
<p>
            There's a weasel word in there-I mentioned that ATMWithdrawal is reasonably
            safe. It's not really safe because there's no enforcement that the <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object locks the appropriate BankAccount object. The type system only
            ensures that some BankAccount object is locked. For example, consider
            the following phony implementation of ATMWithdrawal:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">fakeAcct</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">fakeAcct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This code compiles warning-free but obviously doesn't do the right thing-it
            locks one account and uses another.
          </p>
<p>
            It's important to understand what can be enforced within the realm of
            the C++ type system and what needs to be enforced at runtime. The mechanism
            we've put in place so far ensures that some BankAccount object is locked
            during the call to <code class="computeroutput"><span class="identifier">BankAccount</span><span class="special">::</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            We must enforce at runtime exactly what object is locked.
          </p>
<p>
            If our scheme still needs runtime checks, how is it useful? An unwary
            or malicious programmer can easily lock the wrong object and manipulate
            any BankAccount without actually locking it.
          </p>
<p>
            First, let's get the malice issue out of the way. C is a language that
            requires a lot of attention and discipline from the programmer. C++ made
            some progress by asking a little less of those, while still fundamentally
            trusting the programmer. These languages are not concerned with malice
            (as Java is, for example). After all, you can break any C/C++ design
            simply by using casts "appropriately" (if appropriately is
            an, er, appropriate word in this context).
          </p>
<p>
            The scheme is useful because the likelihood of a programmer forgetting
            about any locking whatsoever is much greater than the likelihood of a
            programmer who does remember about locking, but locks the wrong object.
          </p>
<p>
            Using <code class="computeroutput"><span class="identifier">strict_lock</span></code> permits
            compile-time checking of the most common source of errors, and runtime
            checking of the less frequent problem.
          </p>
<p>
            Let's see how to enforce that the appropriate BankAccount object is locked.
            First, we need to add a member function to the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            class template. The <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">*)</span></code>
            function returns a reference to the locked object.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">strict_lock</span> <span class="special">{</span>
    <span class="special">...</span> <span class="identifier">as</span> <span class="identifier">before</span> <span class="special">...</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mtx</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">mtx</span><span class="special">==&amp;</span><span class="identifier">obj_</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Second, BankAccount needs to use this function compare the locked object
            against this:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">guard</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">guard</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(*</span><span class="keyword">this</span><span class="special">))</span>
            <span class="keyword">throw</span> <span class="string">"Locking Error: Wrong Object Locked"</span><span class="special">;</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The overhead incurred by the test above is much lower than locking a
            recursive mutex for the second time.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking" title="Improving External Locking">Improving
          External Locking</a>
</h5></div></div></div>
<p>
            Now let's assume that BankAccount doesn't use its own locking at all,
            and has only a thread-neutral implementation:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now you can use BankAccount in single-threaded and multi-threaded applications
            alike, but you need to provide your own synchronization in the latter
            case.
          </p>
<p>
            Say we have an AccountManager class that holds and manipulates a BankAccount
            object:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">BankAccount</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            Let's also assume that, by design, AccountManager must stay locked while
            accessing its BankAccount members. The question is, how can we express
            this design constraint using the C++ type system? How can we state "You
            have access to this BankAccount object only after locking its parent
            AccountManager object"?
          </p>
<p>
            The solution is to use a little bridge template <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            that controls access to a BankAccount.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
    <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">()</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="comment">//run time check throw if not locks the same</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj_</span> <span class="special">=</span> <span class="identifier">obj</span><span class="special">;</span>
        <span class="identifier">lockable_</span><span class="special">=</span><span class="identifier">lockable</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> cloaks
            an object of type T, and actually provides full access to that object
            through the get and set member functions, provided you pass a reference
            to a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Owner</span><span class="special">&gt;</span></code>
            object.
          </p>
<p>
            Instead of making <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>
            and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code> of type
            <code class="computeroutput"><span class="identifier">BankAccount</span></code>, <code class="computeroutput"><span class="identifier">AccountManager</span></code> holds objects of type
            <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span>
            <span class="identifier">AccountManager</span><span class="special">&gt;</span></code>:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lockable_base_type</span><span class="special">;</span>
    <span class="identifier">AccountManager</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">checkingAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">savingsAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
    <span class="special">{}</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
<span class="keyword">private</span><span class="special">:</span>

    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The pattern is the same as before - to access the BankAccount object
            cloaked by <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>,
            you need to call <code class="computeroutput"><span class="identifier">get</span></code>.
            To call <code class="computeroutput"><span class="identifier">get</span></code>, you need
            to pass it a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span></code>. The one thing you have to take care
            of is to not hold pointers or references you obtained by calling <code class="computeroutput"><span class="identifier">get</span></code>. If you do that, make sure that
            you don't use them after the strict_lock has been destroyed. That is,
            if you alias the cloaked objects, you're back from "the compiler
            takes care of that" mode to "you must pay attention" mode.
          </p>
<p>
            Typically, you use <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            as shown below. Suppose you want to execute an atomic transfer from your
            checking account to your savings account:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            We achieved two important goals. First, the declaration of <code class="computeroutput"><span class="identifier">checkingAcct_</span></code> and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            makes it clear to the code reader that that variable is protected by
            a lock on an AccountManager. Second, the design makes it impossible to
            manipulate the two accounts without actually locking a BankAccount.
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            what could be called active documentation.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks" title="Allowing other strict locks">Allowing
          other strict locks</a>
</h5></div></div></div>
<p>
            Now imagine that the AccountManager function needs to take a <code class="computeroutput"><span class="identifier">unique_lock</span></code> in order to reduce the
            critical regions. And at some time it needs to access to the <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>. As <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            is not a strict lock the following code doesn't compile:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span> <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>  <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">do_something_else</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            We need a way to transfer the ownership from the <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            to a <code class="computeroutput"><span class="identifier">strict_lock</span></code> during
            the time we are working with <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            and then restore the ownership on <code class="computeroutput"><span class="identifier">unique_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            In order to make this code compilable we need to store either a Lockable
            or a <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span></code>
            reference depending on the constructor. We also need to store which kind
            of reference we have stored, and in the destructor call either to the
            Lockable <code class="computeroutput"><span class="identifier">unlock</span></code> or restore
            the ownership.
          </p>
<p>
            This seems too complicated to me. Another possibility is to define a
            nested strict lock class. The drawback is that instead of having only
            one strict lock we have two and we need either to duplicate every function
            taking a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            or make these function templates. The problem with template functions
            is that we don't profit anymore of the C++ type system. We must add some
            static metafunction that checks that the Locker parameter is a strict
            lock. The problem is that we can not really check this or can we?. The
            <code class="computeroutput"><span class="identifier">is_strict_lock</span></code> metafunction
            must be specialized by the strict lock developer. We need to believe
            it "sur parole". The advantage is that now we can manage with
            more than two strict locks without changing our code. This is really
            nice.
          </p>
<p>
            Now we need to state that both classes are <code class="computeroutput"><span class="identifier">strict_lock</span></code>s.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>
</pre>
<p>
            Well let me show what this <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class looks like and the impacts on the <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            class and the <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code>
            function.
          </p>
<p>
            First <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class will store on a temporary lock the <code class="computeroutput"><span class="identifier">Locker</span></code>,
            and transfer the lock ownership on the constructor. On destruction it
            will restore the ownership. Note the use of <code class="computeroutput"><span class="identifier">lock_traits</span></code>
            and that the <code class="computeroutput"><span class="identifier">Locker</span></code> needs
            to have a reference to the mutex otherwise an exception is thrown.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nested_strict_lock</span>
    <span class="special">{</span>
      <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">MovableLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">syntactic_lock_traits</span><span class="special">&lt;</span><span class="identifier">lockable_type</span><span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">lock_error</span><span class="special">;</span>

    <span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">)</span>  <span class="comment">// Store reference to locker</span>
        <span class="special">,</span> <span class="identifier">tmp_lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">move</span><span class="special">())</span> <span class="comment">// Move ownership to temporary locker </span>
    <span class="special">{</span>
        <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Rollback for coherency purposes </span>
            <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="preprocessor">#endif</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">tmp_lock_</span><span class="special">)</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// ensures it is locked </span>
    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">nested_strict_lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Move ownership to nesting locker </span>
    <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
    <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">==</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>


<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock_</span><span class="special">;</span>
    <span class="identifier">Locker</span> <span class="identifier">tmp_lock_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            get function is now a template function taking a Locker as parameters
            instead of a <code class="computeroutput"><span class="identifier">strict_lock</span></code>.
            We can add test in debug mode that ensure that the Lockable object is
            locked.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// ...</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">StrictLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>

        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// locker is a strict locker "sur parole" </span>
        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span>
                <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// that locks the same type </span>
<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_THREAD_EXTERNALLY_LOCKED_DONT_CHECK_OWNERSHIP</span>  <span class="comment">// define BOOST_THREAD_EXTERNALLY_LOCKED_NO_CHECK_OWNERSHIP if you don't want to check locker ownership</span>
        <span class="keyword">if</span> <span class="special">(!</span> <span class="identifier">lock</span> <span class="special">)</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="comment">// run time check throw if no locked </span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code> function needs
            only to replace the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            by a <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.with"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.with" title="Executing Around a Function">Executing Around
        a Function</a>
</h4></div></div></div>
<p>
          In particular, the library provides a way to lock around the execution
          of a function.
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
    <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">,</span>
    <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span>
<span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">func</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">)...))</span> <span class="special">{</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span>
  <span class="keyword">return</span> <span class="identifier">func</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">)...);</span>
<span class="special">}</span>
</pre>
<p>
          that can be used with regular functions:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">func</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&amp;);</span>
<span class="comment">//...</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">m</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">a</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">func</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">));</span>
</pre>
<p>
          with boost::bind:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">m</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">func</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">a</span><span class="special">))</span>
<span class="special">);</span>
</pre>
<p>
          or with lambda expression:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">a</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">with_lock_guard</span><span class="special">(</span>
    <span class="identifier">m</span><span class="special">,</span>
    <span class="special">[&amp;</span><span class="identifier">a</span><span class="special">](</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
      <span class="comment">// this scope is protected by mutex m</span>
      <span class="identifier">a</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">+</span> <span class="number">4</span><span class="special">;</span>
    <span class="special">},</span>
    <span class="number">5</span>
<span class="special">);</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_concepts"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts" title="Mutex Concepts">Mutex Concepts</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive">Recursive
        Lockable Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept -- C++14</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept -- EXTENSION</a></span></dt>
</dl></div>
<p>
        A mutex object facilitates protection against data races and allows thread-safe
        synchronization of data between threads. A thread obtains ownership of a
        mutex object by calling one of the lock functions and relinquishes ownership
        by calling the corresponding unlock function. Mutexes may be either recursive
        or non-recursive, and may grant simultaneous ownership to one or many threads.
        <span class="bold"><strong>Boost.Thread</strong></span> supplies recursive and non-recursive
        mutexes with exclusive ownership semantics, along with a shared ownership
        (multiple-reader / single-writer) mutex.
      </p>
<p>
        <span class="bold"><strong>Boost.Thread</strong></span> supports four basic concepts
        for lockable objects: <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a>. Each mutex type
        implements one or more of these concepts, as do the various lock types.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable"><code class="computeroutput"><span class="identifier">is_basic_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">BasicLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept models exclusive
          ownership. A type <code class="computeroutput"><span class="identifier">L</span></code> meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requirements if
          the following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until ownership can be obtained for the
                  current thread.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  Prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronizes with this operation.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd>
<p>
                  <span class="bold"><strong>operation_not_permitted</strong></span>: if the
                  thread does not have the privilege to perform the operation.
                </p>
<p>
                  <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                  if the implementation detects that a deadlock would occur.
                </p>
<p>
                  <span class="bold"><strong>device_or_resource_busy</strong></span>: if the
                  mutex is already locked and blocking is not possible.
                </p>
</dd>
<dt><span class="term">Thread safety:</span></dt>
<dd><p>
                  If an exception is thrown then a lock shall not have been acquired
                  for the current thread.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.unlock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership on the same object.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable" title="is_basic_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_basic_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_basic_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            Some of the algorithms on mutexes use this trait via SFINAE.
          </p>
<p>
            This trait is true_type if the parameter L meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              If BOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPES is defined you will need
              to specialize this traits for the models of BasicLockable you could
              build.
            </p></td></tr>
</table></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.is_lockable"><code class="computeroutput"><span class="identifier">is_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements if it meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span></code></a><span class="special">()</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread without blocking.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>
                  returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  Since <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>
                  does not synchronize with a failed subsequent <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>, the visibility rules are weak
                  enough that little would be known about the state after a failure,
                  even in the absence of spurious failures.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns the <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.is_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.is_lockable" title="is_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            Some of the algorithms on mutexes use this trait via SFINAE.
          </p>
<p>
            This trait is true_type if the parameter L meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              If BOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPES is defined you will need
              to specialize this traits for the models of Lockable you could build.
            </p></td></tr>
</table></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.recursive"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive" title="Recursive Lockable Concept">Recursive
        Lockable Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole"><code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code> trait --
          EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable"><code class="computeroutput"><span class="identifier">is_recursive_basic_lockable</span></code> trait --
          EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_lockable"><code class="computeroutput"><span class="identifier">is_recursive_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<p>
          The user could require that the mutex passed to an algorithm is a recursive
          one. Whether a lockable is recursive or not can not be checked using template
          meta-programming. This is the motivation for the following trait.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole" title="is_recursive_mutex_sur_parole trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code> trait --
          EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">:</span> <span class="identifier">false_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;:</span> <span class="identifier">true_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">&lt;</span><span class="identifier">timed_recursive_mutex</span><span class="special">&gt;:</span> <span class="identifier">true_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            The trait <code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code>
            is <code class="computeroutput"><span class="identifier">false_type</span></code> by default
            and is specialized for the provide <code class="computeroutput"><span class="identifier">recursive_mutex</span></code>
            and <code class="computeroutput"><span class="identifier">timed_recursive_mutex</span></code>.
          </p>
<p>
            It should be specialized by the user providing other model of recursive
            lockable.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable" title="is_recursive_basic_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_basic_lockable</span></code> trait --
          EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_basic_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            This traits is true_type if is_basic_lockable and is_recursive_mutex_sur_parole.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_lockable" title="is_recursive_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            This traits is true_type if is_lockable and is_recursive_mutex_sur_parole.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">TimedLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> refines
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to add support
          for timeouts when trying to acquire the lock.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements and the
          following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a> must be released
          through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock_until</span><span class="special">()</span></code> returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock_for</span><span class="special">()</span></code> returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronize with this operation.
                </p></dd>
</dl>
</div>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
            DEPRECATED since 4.00. The following expressions were required on version
            2, but are now deprecated.
          </p>
<p>
            Use instead <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a>.
          </p>
</td></tr>
</table></div>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of an unspecified <code class="computeroutput"><span class="identifier">DurationType</span></code>
              arithmetic compatible with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()+</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept -- C++14</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">SharedLockable</span><span class="special">;</span>  <span class="comment">// C++14</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>shared ownership</em></span> as well as <span class="emphasis"><em>exclusive
          ownership</em></span>. This is the standard multiple-reader / single-write
          model: at most one thread can have exclusive ownership, and if any thread
          does have exclusive ownership, no other threads can have shared or exclusive
          ownership. Alternatively, many threads may have shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a> must be
          released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until shared ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread without
                  blocking.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified duration
                  is elapsed. If the specified duration is already elapsed, behaves
                  as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
            DEPRECATED since 3.00. The following expressions were required on version
            2, but are now deprecated.
          </p>
<p>
            Use instead <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a>.
          </p>
</td></tr>
</table></div>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li></ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept -- EXTENSION</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">UpgradeLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>upgradable ownership</em></span> as well as <span class="emphasis"><em>shared
          ownership</em></span> and <span class="emphasis"><em>exclusive ownership</em></span>. This
          is an extension to the multiple-reader / single-write model provided by
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>: a single
          thread may have <span class="emphasis"><em>upgradable ownership</em></span> at the same time
          as others have <span class="emphasis"><em>shared ownership</em></span>. The thread with
          <span class="emphasis"><em>upgradable ownership</em></span> may at any time attempt to upgrade
          that ownership to <span class="emphasis"><em>exclusive ownership</em></span>. If no other
          threads have shared ownership, the upgrade is completed immediately, and
          the thread now has <span class="emphasis"><em>exclusive ownership</em></span>, which must
          be relinquished by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>,
          just as if it had been acquired by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>.
        </p>
<p>
          If a thread with <span class="emphasis"><em>upgradable ownership</em></span> tries to upgrade
          whilst other threads have <span class="emphasis"><em>shared ownership</em></span>, the attempt
          will fail and the thread will block until <span class="emphasis"><em>exclusive ownership</em></span>
          can be acquired.
        </p>
<p>
          Ownership can also be <span class="emphasis"><em>downgraded</em></span> as well as <span class="emphasis"><em>upgraded</em></span>:
          exclusive ownership of an implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> can be
          downgraded to upgradable ownership or shared ownership, and upgradable
          ownership can be downgraded to plain shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_and_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until" title="m.try_unlock_upgrade_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="m.unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock_shared</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          If `BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS is defined the
          following expressions are also required:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
          If the ownership type is changed through a call to one of the <code class="computeroutput"><span class="identifier">unlock_xxx_and_lock_yyy</span><span class="special">()</span></code>
          functions, ownership must be released through a call to the unlock function
          corresponding to the new level of ownership.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until upgrade ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  Prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership on the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempts to obtain upgrade ownership of the mutex for the calling
                  thread without blocking. If upgrade ownership is not obtained,
                  there is no effect and try_lock_upgrade() immediately returns.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. Attempts
                  to obtain upgrade lock ownership for the calling thread within
                  the relative timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>.
                  If the time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to obtain upgrade ownership of the mutex.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread must hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the shared ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>).
                  The function shall return within the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> only if it has obtained
                  exclusive ownership of the mutex object. For this conversion to
                  be successful, this thread must be the only thread holding any
                  ownership of the lock at the moment of conversion. If the conversion
                  is not successful, the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread within the absolute
                  timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain exclusive ownership
                  without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock at the moment of conversion.
                  If the conversion is not successful, the shared ownership of the
                  mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically converts the ownership from exclusive to shared for
                  the calling thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread without blocking. For
                  this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object. If the conversion is not successful,
                  the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to upgrade
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  upgrade ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of m is
                  retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread within the absolute timeout
                  specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of the mutex
                  is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code> without blocking.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>. If any other threads have
                  shared ownership, blocks until exclusive ownership can be acquired.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  that obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold an upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  upgrade to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the upgrade ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold an upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from upgrade to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread shall be the
                  only thread holding any ownership of the lock at the moment of
                  conversion. If the conversion is not successful, the upgrade ownership
                  of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_u